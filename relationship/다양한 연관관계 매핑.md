
# 다양한 연관관계 매핑

### 💛 엔티티 연관관계 매핑 시 고려해야 할 요소들 💛

✅ 다중성

- 다대일(@ManyToOne)
- 일대다(@OneToMany)
- 일대일(@OneToOne)
- 다대다(@ManyToMany) - 거의 사용하지 않음

▶ 다중성을 판단하기 어려울 경우, 상대방측을 고려해서 판단하면 도움이 될 수 있음

✅ 단방향, 양방향

테이블은 외래키 하나로 양방향으로 쿼리가 가능하므로 방향이라는 개념이 없지만,
`객체`는 참조용 필드를 갖고 있는 객체만 연관된 객체를 조회할 수 있어서 `방향`이라는 개념이 존재!!

- `단방향` : 객체 관계에서 한 쪽만 참조하는 것
- `양방향` : 양쪽이 서로 참조하는 것

✅ 연관관계의 주인

- 양방향 관계에서 `외래키를 관리하는 측`
- 연관관계의 주인이 아닌 측에서는 읽기만 가능하고,
연관관계의 주인만이 외래키를 변경하고 읽을 수도 있음!!
- `연관관계 주인은 mappedBy 속성을 사용하지 않음`
- `연관관계의 주인이 아닌 곳에서` mappedBy속성으로 주인측에서의 변수명으로 관계를 맺어준다!!

## 1. 다대일(@ManyToOne)

- 다대일의 반대방향 : `항상 일대다`!!
(반대로, 일대다의 반대방향은 "다대일"~)

- `항상 연관관계의 주인은 다측!!`

### 1-1. 다대일 단방향

![다대일 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EB%8B%A8%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

위와 같이 Member 내부에 Team이 존재하고, Team 내부에는 Member가 없는 단방향 관계를 생각해보자
```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
  
    @ManyToOne  
 @JoinColumn(name = "team_id")  
    private Team team;  
}
```

```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name ="team_id")//이부분 미지정시 Team.id로 인식!!  
  private Long id;  
  
    private String name;  
}
```

```java
package com.example.ch06jpastart6.test;  
  
import com.example.ch06jpastart6.domain.entity.Member;  
import com.example.ch06jpastart6.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setTeam(team);  
        entityManager.persist(member);  
  
        Member findMember =  
                entityManager.find(Member.class,2L);  
  
        Team findTeam = findMember.getTeam();  
  
        System.out.println("find team: "+findTeam);  
    }  
}
```

그러면 아래처럼 Member를 통해 Team 정보를 확인해볼 수 있다
```
00:23:13.139 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 2, using strategy: org.hibernate.id.enhanced.SequenceStyleGenerator
find team: Team(id=1, name=team1)
```

### 1-2. 다대일 양방향

![다대일 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EC%96%91%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

이번에는 위와 같이 Member와 Team 각각 내부에 각자에 대한 참조 필드를 마련해두고, 단 다측인 Member에서 FK를 관리하도록 하는 양방향 관계를 살펴보자
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @ManyToOne  
 @JoinColumn(name ="team_id")//상대측 id  private Team team;  
  
    public void setTeam(Team team1){  
        //변경되는 관계를 위한 초기화  
  if(this.team !=null){  
            this.team.getMembers().remove(this);  
        }  
        this.team = team1;  
        team.getMembers().add(this);  
    }  
}
```
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToMany(mappedBy = "team")//상대방인 Team이 나Member측에서 뭐라고 불리는지를 mappedBy에 맺어줌  
  //StackOverflowError를 막기 위함  
  @ToString.Exclude  
  private List<Member> members = new ArrayList<>();  
}
```
IDENTITY 전략을 사용한 이유는 , auto전략을 사용하면 자체적으로 hibernate_sequence가 공유되어 a 엔티티와 b엔티티에서 같이 사용되어 혼재될 수 있어서 선택하였는데
MySQL을 생각하던 중 identity 전략을 생각하게 되었다
하지만, table 전략도 괜찮을 것 같다
```java
package com.example.ch06jpastart7.test;  
  
import com.example.ch06jpastart7.domain.entity.Member;  
import com.example.ch06jpastart7.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneBiDirTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory=  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager=  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("mem1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("mem2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
  
        System.out.println("find members by team: "+findTeam.getMembers());  
        //member에서 team을 다시 확인해보기  
  findTeam.getMembers().forEach(member -> {  
            System.out.println("team->members->team: "+member.getTeam());  
        });  
    }  
}
```

위와 같이 Team을 찾고, 이를 이용해서 Member들을 찾을 수 있고, 이 member들 각각에서도 Team을 알아볼 수 있다
```
16:26:37.511 [main] DEBUG org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl - HHH000387: ResultSet's statement was not registered
find members by team: [Member(id=1, username=mem1, team=Team(id=1, name=team1)), Member(id=2, username=mem2, team=Team(id=1, name=team1))]
team->members->team: Team(id=1, name=team1)
team->members->team: Team(id=1, name=team1)
```
그리고 위에서 볼 수 있는 점은 Members.team이 연관관계의 주인이기 때문에 setTeam으로 외래키를 변경할 수 있는 모습을 확인해볼 수 있다

🧡 그리고!! 위에서 본 것처럼 양방향 연관관계는 항상 서로를 참조해야 한다!!


## 2. 일대다

### 2-1. 일대다 단방향

- 일대다 단방향은 JPA 2.0부터 지원
![일대다 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

⚠ `일대다` 에서 `1` 측에서 FK를 관리!

- `@JoinColumn(name = 다측에서의 fk 키 이름)` 으로 맺어주어서 중간테이블 생성이 일어나지 않도록 하기
- 항상 외래키는 `다`측에서 존재하기 때문에, 실제 db에서는 MEMBER 측에 외래키 TEAM_ID가 존재한다
하지만, 객체에서 Member측에서는 외래키를 매핑할 수 있는 참조필드가 없어서 대신에 Team엔티티측에서의 Team.members로 참조하게 됨으로써
`연관관계 주인의 반대측`에서 외래키를 관리하게 되는 모습이 보이게 된다!!

▶ `일대다 단방향`의 단점!!

- 엔티티 저장과 연관관계 처리를 insert sql 외에 update sql을 추가적으로 실행해야!!

```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@TableGenerator(  
        name = "member_seq_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_seq_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
}
```
```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Data  
@TableGenerator(  
        name ="team_table_generator",  
        table = "team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    private String name;  
  
    //일대다 단방향  
  @OneToMany  
 @JoinColumn(name = "team_id")//member 테이블의 fk  private List<Member> members = new ArrayList<>();  
}
```
```java
package com.example.ch06jpastart8.test;  
  
import com.example.ch06jpastart8.domain.entity.Member;  
import com.example.ch06jpastart8.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    public static void logic(EntityManager entityManager){  
        Member member1= new Member();  
        member1.setUsername("member1");  
        entityManager.persist(member1);  
  
        Member member2=new Member();  
        member2.setUsername("member2");  
        entityManager.persist(member2);  
  
        Team team = new Team();  
        team.setName("team1");  
        team.setMembers(List.of(member1,member2));  
        entityManager.persist(team);  
    }  
}
```
먼저 위와 같이 연관관계에 놓여진 두 엔티티를 만들고, 영속성 컨텍스트로 관리하게 되면, 아래와 같이 update sql이 추가적으로 실행되는 것을 확인해볼 수 있다

```
19:57:25.360 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.366 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.368 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
19:57:25.371 [main] DEBUG org.hibernate.persister.collection.AbstractCollectionPersister - Inserting collection: [com.example.ch06jpastart8.domain.entity.Team.members#1]
19:57:25.371 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
19:57:25.372 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
```

위의 경우를 다시 풀어서 정리해보면, 

- 처음에는 연관관계에 대한 정보를 Team.members 가 관리하기 때문에 Member 엔티티를 저장할 때는 Member 테이블의 TEAM_ID 외래키에 아무런 값도 저장되지 않는다!
- 대신, TEAM 엔티티를 저장할 때 Team.members의 참조값을 확인해서 MEMBER 테이블에 있는 TEAM_ID 외래키를 업데이트 하는 모습을 알 수 있다! 

💛 이렇듯, 일대일 단방향은 성능문제도 있지만, 관리도 부담스럽기 때문에(db 작업량뿐 아니라, fk 관리가 번거로움) `일대다 단방향 매핑 대신, 다대일 양방향 매핑을 사용하는 것`이  보다 권장된다!


### 2-2. 일대다 양방향
![일대다 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 일대다 양방향 매핑은 존재하지 않는 대신, `다대일 양방향 매핑`을 사용해야 함!!
- 1:N, N:1에서 연관관계의 주인은 항상 `다`측!! `@ManyToOne`을 사용한 측!!
▶ @ManyToOne을 사용한 측에는 mappedBy가 없음!
- 일대다 양방향 매핑이 아예 불가능한 것은 아니라서, 일대다 단방향 매핑의 반대편인 "다"측에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 됨!!

간단하게 저장하고 조회하는 결과는 다대일 양방향과 유사하지만, 연관관계의 주인이 1측이라는 점과, 관리의 번거로움이 존재한다
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@NoArgsConstructor  
@AllArgsConstructor  
@Getter  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "team_table_generator",  
        table ="team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
  
    @OneToMany(mappedBy = "team")  
    private List<Member> members = new ArrayList<>();  
  
  
    public void addMember(Member member){  
        this.members.add(member);  
  
        //무한루프에 빠지지 않도록 체크  
  if(member.getTeam()!=this){  
            member.setTeam(this);  
        }  
    }  
}
```
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@NoArgsConstructor  
@AllArgsConstructor  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    //읽기전용  
  @ManyToOne  
 @JoinColumn(name ="team_id",insertable = false,updatable = false)//fk키값  
  @ToString.Exclude  
  private Team team;  
  
    public void setTeam(Team team){  
        if(this.team != null){  
            this.team.getMembers().remove(this);//지금 member와 연결 초기화  
  }  
  
        this.team = team;  
        this.team.getMembers().add(this);  
    }  
}
```

```java
package com.example.ch06jpastart9.test;  
  
import com.example.ch06jpastart9.domain.entity.Member;  
import com.example.ch06jpastart9.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("member1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("member2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
        List<Member> findByTeam = findTeam.getMembers();  
        System.out.println("team으로 접근된 members: "+findByTeam);  
  
        Member findMember = entityManager.find(Member.class,1L);  
        Team findByMember = findMember.getTeam();  
        System.out.println("member로 접근된 team: "+findByMember);  
    }  
}
```

```
01:31:50.486 [main] DEBUG org.hibernate.loader.collection.plan.AbstractLoadPlanBasedCollectionInitializer - Done loading collection
team으로 접근된 members: [Member(id=1, username=member1), Member(id=2, username=member2)]
member로 접근된 team: Team(id=1, name=team1, members=[Member(id=1, username=member1), Member(id=2, username=member2)])
```
🧡 될 수 있으면, 다대일 양방향 매핑을 이용하자!

## 3. 일대일

- 반대방향도 일대일
- 주테이블이나 대상 테이블 중 어느 곳이나 외래키를 가질 수 있다는 점이 일대다/다대일과의 차이점!

1️⃣ 주 테이블에 외래키

- 주 테이블에 외래키를 두고, 대상 테이블을 참조
- 객체 지향 개발자들이 선호하는 방식
- 장점: 주 테이블만 확인해도 대상 테이블과의 연관관계 존재여부를 확인 가능

2️⃣ 대상 테이블에 외래키

- 대상 테이블에 외래키를 두는 방식
- 전통적인 DB 개발자들이 선호하는 방식
- 장점: 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지 가능

### 3-1. 주 테이블에 외래키

#### 3-1-1. 주 테이블에 외래키-단방향
![주 테이블에 외래키가 있는 경우- 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EC%A3%BC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 현재 위와 같이 FK가 주테이블인 Member 테이블에 있는 경우,

1️⃣ `주테이블에 해당되는 엔티티측`에 `@OneToOne` 을 붙이기

2️⃣ `주테이블에 해당되는 엔티티측`에 `@JoinColumn` 을 붙이기

3️⃣ 다대일 단방향과 유사(FK 를 관리하는 측에서 참조필드를 관리)

위와 같은 특징이 있다

간단하게 위와 동일하게 엔티티를 만들고, 저장 및 조회를 진행해보자

```java
package com.example.ch06jpastart10.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
}
```
```java
package com.example.ch06jpastart10.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToOne  
 @JoinColumn(name ="locker_id")  
    @Setter  
  private Locker locker;//일대일 연관관계  
}
```
```java
package com.example.ch06jpastart10.test;  
  
import com.example.ch06jpastart10.domain.entity.Locker;  
import com.example.ch06jpastart10.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
/**  
 * @author gs813  
 * 일대일 주테이블에 외래키가 있는 경우-단방향  
  */  
public class OneToOneMainUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        Locker locker = new Locker();  
        locker.setName("locker1");  
        entityManager.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setLocker(locker);  
        entityManager.persist(member);  
    }  
  
    static void search(EntityManager entityManager){  
        Member findMember = entityManager.find(Member.class,1L);  
        System.out.println("find 1L member: "+findMember);  
        System.out.println("find locker by member: "+findMember.getLocker());  
    }  
}
```
```
16:04:39.136 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists Locker CASCADE 
Hibernate: 
    
    drop table if exists Locker CASCADE 
16:04:39.138 [main] INFO org.hibernate.orm.connections.access - HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@2cc75074] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
16:04:39.139 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists locker_sequences CASCADE 
Hibernate: 
    
    drop table if exists locker_sequences CASCADE 
16:04:39.139 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists Member CASCADE 
Hibernate: 
    
    drop table if exists Member CASCADE 
16:04:39.144 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists member_sequences CASCADE 
Hibernate: 
    
    drop table if exists member_sequences CASCADE 
16:04:39.150 [main] DEBUG org.hibernate.SQL - 
    
    create table Locker (
       locker_id bigint not null,
        name varchar(255),
        primary key (locker_id)
    )
Hibernate: 
    
    create table Locker (
       locker_id bigint not null,
        name varchar(255),
        primary key (locker_id)
    )
16:04:39.150 [main] INFO org.hibernate.orm.connections.access - HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@6325f352] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
16:04:39.153 [main] DEBUG org.hibernate.SQL - 
    
    create table locker_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    create table locker_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
16:04:39.155 [main] DEBUG org.hibernate.SQL - 
    
    insert into locker_sequences(sequence_name, next_val) values ('locker_seq',0)
Hibernate: 
    
    insert into locker_sequences(sequence_name, next_val) values ('locker_seq',0)
16:04:39.158 [main] DEBUG org.hibernate.SQL - 
    
    create table Member (
       member_id bigint not null,
        username varchar(255),
        locker_id bigint,
        primary key (member_id)
    )
Hibernate: 
    
    create table Member (
       member_id bigint not null,
        username varchar(255),
        locker_id bigint,
        primary key (member_id)
    )
16:04:39.160 [main] DEBUG org.hibernate.SQL - 
    
    create table member_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    create table member_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
16:04:39.163 [main] DEBUG org.hibernate.SQL - 
    
    insert into member_sequences(sequence_name, next_val) values ('member_seq',0)
Hibernate: 
    
    insert into member_sequences(sequence_name, next_val) values ('member_seq',0)
16:04:39.164 [main] DEBUG org.hibernate.SQL - 
    
    alter table Member 
       add constraint FKmb6i4bdpv6jlenq04hjefd41v 
       foreign key (locker_id) 
       references Locker
Hibernate: 
    
    alter table Member 
       add constraint FKmb6i4bdpv6jlenq04hjefd41v 
       foreign key (locker_id) 
       references Locker
16:04:39.329 [main] DEBUG org.hibernate.SQL - 
    select
        tbl.next_val 
    from
        locker_sequences tbl 
    where
        tbl.sequence_name=? for update
            
Hibernate: 
    select
        tbl.next_val 
    from
        locker_sequences tbl 
    where
        tbl.sequence_name=? for update
            
16:04:39.332 [main] DEBUG org.hibernate.SQL - 
    update
        locker_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
Hibernate: 
    update
        locker_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?

16:04:39.357 [main] DEBUG org.hibernate.SQL - 
    select
        tbl.next_val 
    from
        member_sequences tbl 
    where
        tbl.sequence_name=? for update
            
Hibernate: 
    select
        tbl.next_val 
    from
        member_sequences tbl 
    where
        tbl.sequence_name=? for update
            
16:04:39.359 [main] DEBUG org.hibernate.SQL - 
    update
        member_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
Hibernate: 
    update
        member_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
16:04:39.362 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
find 1L member: Member(id=1, username=member1, locker=Locker(id=1, name=locker1))
find locker by member: Locker(id=1, name=locker1)
16:04:39.427 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Locker
        (name, locker_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Locker
        (name, locker_id) 
    values
        (?, ?)
16:04:39.460 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (locker_id, username, member_id) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        Member
        (locker_id, username, member_id) 
    values
        (?, ?, ?)

```

그 결과, 위와 같이 Member를 통해 Locker를 확인할 수 있음을 알 수 있다
💙 `SELECT FOR UPDATE`
https://jaenjoy.tistory.com/28

- 조회된 row 에 대해서는 트랜잭션이 종료(commit, rollback) 되기 전까지 모든 crud가 차단되는 것

💚 행단위 ,테이블 단위 잠금

1️⃣ 테이블 단위 잠금 Table Level Locking

- 테이블 전체에 대한 접근 차단
- 같은 시간에 유입된 사용자가 요청한 동일 테이블의 다른 row에 대한 요청도 못받기 때문에 동시성 문제 해결에는 부적합

2️⃣ 행 단위 잠금 Row Level Locking

- 한 테이블 내에서 하나의 행에 대한 접근만 차단

✅ MySQL 기본 isolation level : Repeatable read

✅ Oracle 기본 isolation level : Read Committed

⚠ 트랜잭션 고립화 수준 Isolation level
reference: [구루비 트랜잭션 수준 읽기 일관성](http://wiki.gurubee.net/pages/viewpage.action?pageId=21200923#:~:text=%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EC%88%98%EC%A4%80%20%EC%9D%BD%EA%B8%B0%20%EC%9D%BC%EA%B4%80%EC%84%B1(%20Transaction,%EC%9D%BD%EC%96%B4%20%EB%93%A4%EC%9D%B4%EB%8A%94%20%EA%B2%83%EC%9D%84%20%EB%A7%90%ED%95%9C%EB%8B%A4.&text=%EC%9E%88%EC%9D%84%20%EC%88%98%20%EC%9E%88%EB%8B%A4.,%EC%9D%80%20%EC%9D%BD%EC%9D%84%20%EC%88%98%20%EC%9E%88%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4.)


[트랜잭션 고립화 수준, 발생가능한 현상, 트랜잭션 회복기법](https://rebro.kr/165) ▶ 회복기법은 다음에 꼭 읽고 정리하기!!

- isolation level  ⬆ ▶ 일관성(consistency)⬆&& 동시성(concurrency)⬇

1. 레벨 0 : Read Uncommitted

- 트랜잭션에서 처리 중인(=아직 커밋되지 않은) 데이터를 다른 트랜잭션에서 읽는 것을 허용
- Dirty read, Non-repeatable read, Phantom read 현상 발생
- 오라클 미지원

2. 레벨 1: Read Committed

- 커밋되어 확정된 데이터만 읽기
- Dirty read 방지
- 대부분의 RDBMS가 채택
- Non-Repeatable Read, Phantom Read 발생 가능

3. 레벨 2: Repeatable Read

- 선행 트랜잭션이 읽은 데이터는 해당 트랜잭션이 종료되기(commit, rollback) 전까지 `후행 트랜잭션이 갱신하거나 삭제하는 것을 불허`해서 데이터의 일관성을 유지
- Phantom read 현상 발생 가능
- Oracle : for update절로 접근 가능
- Phantom Read 발생 가능

4. 레벨 3 : Serializable Read

-   신형 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 산입하는 것도 막아줌

-   완벽하게 읽기 일관성 모드를 제공

💘 고립화 수준에 따라 발생할 수 있는 현상

1️⃣ Dirty Read

- 아직 커밋되지 않은 데이터를 다른 트랜잭션에서 읽을 경우 발생

2️⃣ Non-Repeatable Read

- 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, `그 사이 다른 트랜잭션이 값을 수정하거나 삭제함`으로써  `쿼리 실행 결과가 상이하게 나타나는 현상`

3️⃣ Phantom Read

- 한 트랜잭션 내에서 같은 데이터를 두 번  이상 읽을 때, `다른 트랜잭션이 중간에 값을 추가`함으로써 `첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 발생` 하는 현상

#### 3-1-2. 주 테이블에 외래키-양방향

![주 테이블에 외래키가 있는 경우 - 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EC%A3%BC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 이번에는 위의 `주 테이블에 외래키가 있는 경우- 단방향` 에 `반대방향을 추가` 해서 양방향으로 생각, 접근해보자
- 주테이블이 연관관계의 주인이기 때문에,

1️⃣ 주테이블

- @OneToOne
- @JoinColumn(name = fk 명)

2️⃣ 대상테이블

- @OneToOne(mappedBy = 대상테이블이 주테이블측에서 불리고 있는 필드명)

위를 참고해서 주테이블에 외래키가 있을 경우 단방향에 반대방향을 추가해서 확인해보자! 단, 오버플로우 에러 등을 막기 위해서 양측에 참조필드에 대해서 `@ToString.Exclude 를 붙여주자(사실 한쪽에만 붙여도 되지만, 양측에서 똑같이 적용해주고 싶어서 양측에 다 붙여주었다)`
```java
package com.example.ch06jpastart11.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {//대상테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToOne(mappedBy = "locker")//member.class에서 locker가 어떻게 되어있는지 확인  
  @Setter  
 @ToString.Exclude  private Member member;  
}
```

```java
package com.example.ch06jpastart11.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {//주테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
      
    @Setter  
  private String username;  
      
    @OneToOne  
 @JoinColumn(name ="locker_id")//연관관계 주인측(fk이름)  
  @Setter  
 @ToString.Exclude  private Locker locker;  
}
```

```java
package com.example.ch06jpastart11.test;  
  
import com.example.ch06jpastart11.domain.entity.Locker;  
import com.example.ch06jpastart11.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class OneToOneMainBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        Locker locker = new Locker();  
        locker.setName("locker1");  
        entityManager.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setLocker(locker);  
        entityManager.persist(member);  
  
        //양방향이므로 양측에서 관계 설정  
  locker.setMember(member);  
    }  
  
    static void search(EntityManager entityManager){  
        Locker findLocker = entityManager.find(Locker.class,1L);  
        Member findMember = entityManager.find(Member.class,1L);  
  
        System.out.println("Locker로 Member 정보 확인: [Locker: "+findLocker+"], member by locker: ["+findLocker.getMember()+"]");  
        System.out.println("Member로 Locker 정보 확인: [Member: "+findMember+"], locker by member: ["+findMember.getLocker()+"]");  
    }  
}
```

그러면 아래와 같이 양측에서 서로를 확인해볼 수 있음을 알 수 있다
```
00:43:13.673 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
Locker로 Member 정보 확인: [Locker: Locker(id=1, name=locker1)], member by locker: [Member(id=1, username=member1)]
Member로 Locker 정보 확인: [Member: Member(id=1, username=member1)], locker by member: [Locker(id=1, name=locker1)]
```

### 3-2. 대상 테이블에 외래키

#### 3-2-1. 대상 테이블에 외래키가 있는 경우- 단방향

![일대일 관계 - 대상 테이블에 외래키가 있는 경우의 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EB%8C%80%EC%83%81%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 이경우는 jpa에서 지원되지 않음(일대다 양방향도 원래는 지원되지 않는 것처럼! 하지만 일대다 양방향은 읽기 전용으로 만들어서 해결 가능)
- 1) 이 경우는 관계를 Locker에서 Member 방향으로 수정하거나,
- 2) 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야!

#### 3-2-2. 대상 테이블에 외래키가 있는 경우- 양방향

![일대일 관계 - 대상 테이블에 외래키가 있는 경우의 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EB%8C%80%EC%83%81%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 일대일 매핑에서 대상 테이블에 FK를 두고 싶다면 `양방향`으로 매핑하고, 대상 엔티티를 연관관계의 주인으로 만들기

간단하게 두 엔티티를 만들어서 저장하고, 조회해보면 아래와 같이 양측에서 각각을 확인해볼 수 있음을 알 수 있다
```java
package com.example.ch06jpastart12.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {//대상테이블->연관관계 주인으로 만들 것  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToOne  
 @JoinColumn(name = "member_id")  
    @Setter  
 @ToString.Exclude  private Member member;  
}
```

```java
package com.example.ch06jpastart12.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {//주테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToOne(mappedBy = "member")//Member가 Locker에 어떻게 되어 있는지 지정(연관관계 주인이 Locker이므로 Member는 mappedBy로 받기)  
  @Setter  
 @ToString.Exclude  private Locker locker;  
}
```

```java
package com.example.ch06jpastart12.test;  
  
import com.example.ch06jpastart12.domain.entity.Locker;  
import com.example.ch06jpastart12.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
/**  
 * @author gs813  
 * 대상테이블에 외래키가 있는 경우 양방향  
  * - 연관관계주인을 대상테이블로 하고 양방향으로 생각  
  */  
public class OneToOneAnotherSideBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager) {  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManagger) {  
        Locker locker = new Locker();  
        locker.setName("locker");  
        entityManagger.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member");  
        member.setLocker(locker);  
        entityManagger.persist(member);  
  
        locker.setMember(member);  
    }  
  
    static void search(EntityManager entityManager) {  
        Locker findLocker = entityManager.find(Locker.class, 1L);  
        Member findMember = entityManager.find(Member.class, 1L);  
  
        System.out.println("Locker로 Member 정보 확인: [Locker: " + findLocker + "], member by locker: [" + findLocker.getMember() + "]");  
        System.out.println("Member로 Locker 정보 확인: [Member: " + findMember + "], locker by member: [" + findMember.getLocker() + "]");  
    }  
}
```

```
01:15:48.454 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
Locker로 Member 정보 확인: [Locker: Locker(id=1, name=locker)], member by locker: [Member(id=1, username=member)]
Member로 Locker 정보 확인: [Member: Member(id=1, username=member)], locker by member: [Locker(id=1, name=locker)]
```

## 4. 다대다 관계

- RDBMS는 테이블 2개로 다대다 관계를 표현할 수 없지만, 객체는 객체 2개로 다대다 관계를 만들 수 있음!!

![다대다 연관관계](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EB%8B%A4%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84.jpg?raw=true)

### 4-1. 다대다 단방향

- 사실상 위의 개념으로 생각하면, Member_Product가 연관관계의 주인이지만, Member 측에서 관리한다고 

1️⃣ Member 측

- M

2️⃣ Product 측
