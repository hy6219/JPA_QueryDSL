
# 다양한 연관관계 매핑

### 💛 엔티티 연관관계 매핑 시 고려해야 할 요소들 💛

✅ 다중성

- 다대일(@ManyToOne)
- 일대다(@OneToMany)
- 일대일(@OneToOne)
- 다대다(@ManyToMany) - 거의 사용하지 않음

▶ 다중성을 판단하기 어려울 경우, 상대방측을 고려해서 판단하면 도움이 될 수 있음

✅ 단방향, 양방향

테이블은 외래키 하나로 양방향으로 쿼리가 가능하므로 방향이라는 개념이 없지만,
`객체`는 참조용 필드를 갖고 있는 객체만 연관된 객체를 조회할 수 있어서 `방향`이라는 개념이 존재!!

- `단방향` : 객체 관계에서 한 쪽만 참조하는 것
- `양방향` : 양쪽이 서로 참조하는 것

✅ 연관관계의 주인

- 양방향 관계에서 `외래키를 관리하는 측`
- 연관관계의 주인이 아닌 측에서는 읽기만 가능하고,
연관관계의 주인만이 외래키를 변경하고 읽을 수도 있음!!
- `연관관계 주인은 mappedBy 속성을 사용하지 않음`
- `연관관계의 주인이 아닌 곳에서` mappedBy속성으로 주인측에서의 변수명으로 관계를 맺어준다!!

## 1. 다대일(@ManyToOne)

- 다대일의 반대방향 : `항상 일대다`!!
(반대로, 일대다의 반대방향은 "다대일"~)

- `항상 연관관계의 주인은 다측!!`

### 1-1. 다대일 단방향

![다대일 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EB%8B%A8%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

위와 같이 Member 내부에 Team이 존재하고, Team 내부에는 Member가 없는 단방향 관계를 생각해보자
```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
  
    @ManyToOne  
 @JoinColumn(name = "team_id")  
    private Team team;  
}
```

```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name ="team_id")//이부분 미지정시 Team.id로 인식!!  
  private Long id;  
  
    private String name;  
}
```

```java
package com.example.ch06jpastart6.test;  
  
import com.example.ch06jpastart6.domain.entity.Member;  
import com.example.ch06jpastart6.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setTeam(team);  
        entityManager.persist(member);  
  
        Member findMember =  
                entityManager.find(Member.class,2L);  
  
        Team findTeam = findMember.getTeam();  
  
        System.out.println("find team: "+findTeam);  
    }  
}
```

그러면 아래처럼 Member를 통해 Team 정보를 확인해볼 수 있다
```
00:23:13.139 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 2, using strategy: org.hibernate.id.enhanced.SequenceStyleGenerator
find team: Team(id=1, name=team1)
```

### 1-2. 다대일 양방향

![다대일 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EC%96%91%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

이번에는 위와 같이 Member와 Team 각각 내부에 각자에 대한 참조 필드를 마련해두고, 단 다측인 Member에서 FK를 관리하도록 하는 양방향 관계를 살펴보자
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @ManyToOne  
 @JoinColumn(name ="team_id")//상대측 id  private Team team;  
  
    public void setTeam(Team team1){  
        //변경되는 관계를 위한 초기화  
  if(this.team !=null){  
            this.team.getMembers().remove(this);  
        }  
        this.team = team1;  
        team.getMembers().add(this);  
    }  
}
```
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToMany(mappedBy = "team")//상대방인 Team이 나Member측에서 뭐라고 불리는지를 mappedBy에 맺어줌  
  //StackOverflowError를 막기 위함  
  @ToString.Exclude  
  private List<Member> members = new ArrayList<>();  
}
```
IDENTITY 전략을 사용한 이유는 , auto전략을 사용하면 자체적으로 hibernate_sequence가 공유되어 a 엔티티와 b엔티티에서 같이 사용되어 혼재될 수 있어서 선택하였는데
MySQL을 생각하던 중 identity 전략을 생각하게 되었다
하지만, table 전략도 괜찮을 것 같다
```java
package com.example.ch06jpastart7.test;  
  
import com.example.ch06jpastart7.domain.entity.Member;  
import com.example.ch06jpastart7.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneBiDirTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory=  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager=  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("mem1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("mem2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
  
        System.out.println("find members by team: "+findTeam.getMembers());  
        //member에서 team을 다시 확인해보기  
  findTeam.getMembers().forEach(member -> {  
            System.out.println("team->members->team: "+member.getTeam());  
        });  
    }  
}
```

위와 같이 Team을 찾고, 이를 이용해서 Member들을 찾을 수 있고, 이 member들 각각에서도 Team을 알아볼 수 있다
```
16:26:37.511 [main] DEBUG org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl - HHH000387: ResultSet's statement was not registered
find members by team: [Member(id=1, username=mem1, team=Team(id=1, name=team1)), Member(id=2, username=mem2, team=Team(id=1, name=team1))]
team->members->team: Team(id=1, name=team1)
team->members->team: Team(id=1, name=team1)
```
그리고 위에서 볼 수 있는 점은 Members.team이 연관관계의 주인이기 때문에 setTeam으로 외래키를 변경할 수 있는 모습을 확인해볼 수 있다

🧡 그리고!! 위에서 본 것처럼 양방향 연관관계는 항상 서로를 참조해야 한다!!


## 2. 일대다

### 2-1. 일대다 단방향

- 일대다 단방향은 JPA 2.0부터 지원
![일대다 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

⚠ `일대다` 에서 `1` 측에서 FK를 관리!

- `@JoinColumn(name = 다측에서의 fk 키 이름)` 으로 맺어주어서 중간테이블 생성이 일어나지 않도록 하기
- 항상 외래키는 `다`측에서 존재하기 때문에, 실제 db에서는 MEMBER 측에 외래키 TEAM_ID가 존재한다
하지만, 객체에서 Member측에서는 외래키를 매핑할 수 있는 참조필드가 없어서 대신에 Team엔티티측에서의 Team.members로 참조하게 됨으로써
`연관관계 주인의 반대측`에서 외래키를 관리하게 되는 모습이 보이게 된다!!

▶ `일대다 단방향`의 단점!!

- 엔티티 저장과 연관관계 처리를 insert sql 외에 update sql을 추가적으로 실행해야!!

```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@TableGenerator(  
        name = "member_seq_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_seq_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
}
```
```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Data  
@TableGenerator(  
        name ="team_table_generator",  
        table = "team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    private String name;  
  
    //일대다 단방향  
  @OneToMany  
 @JoinColumn(name = "team_id")//member 테이블의 fk  private List<Member> members = new ArrayList<>();  
}
```
```java
package com.example.ch06jpastart8.test;  
  
import com.example.ch06jpastart8.domain.entity.Member;  
import com.example.ch06jpastart8.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    public static void logic(EntityManager entityManager){  
        Member member1= new Member();  
        member1.setUsername("member1");  
        entityManager.persist(member1);  
  
        Member member2=new Member();  
        member2.setUsername("member2");  
        entityManager.persist(member2);  
  
        Team team = new Team();  
        team.setName("team1");  
        team.setMembers(List.of(member1,member2));  
        entityManager.persist(team);  
    }  
}
```
먼저 위와 같이 연관관계에 놓여진 두 엔티티를 만들고, 영속성 컨텍스트로 관리하게 되면, 아래와 같이 update sql이 추가적으로 실행되는 것을 확인해볼 수 있다

```
19:57:25.360 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.366 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.368 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
19:57:25.371 [main] DEBUG org.hibernate.persister.collection.AbstractCollectionPersister - Inserting collection: [com.example.ch06jpastart8.domain.entity.Team.members#1]
19:57:25.371 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
19:57:25.372 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
```

위의 경우를 다시 풀어서 정리해보면, 

- 처음에는 연관관계에 대한 정보를 Team.members 가 관리하기 때문에 Member 엔티티를 저장할 때는 Member 테이블의 TEAM_ID 외래키에 아무런 값도 저장되지 않는다!
- 대신, TEAM 엔티티를 저장할 때 Team.members의 참조값을 확인해서 MEMBER 테이블에 있는 TEAM_ID 외래키를 업데이트 하는 모습을 알 수 있다! 

💛 이렇듯, 일대일 단방향은 성능문제도 있지만, 관리도 부담스럽기 때문에(db 작업량뿐 아니라, fk 관리가 번거로움) `일대다 단방향 매핑 대신, 다대일 양방향 매핑을 사용하는 것`이  보다 권장된다!


### 2-2. 일대다 양방향
![일대다 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 일대다 양방향 매핑은 존재하지 않는 대신, `다대일 양방향 매핑`을 사용해야 함!!
- 1:N, N:1에서 연관관계의 주인은 항상 `다`측!! `@ManyToOne`을 사용한 측!!
▶ @ManyToOne을 사용한 측에는 mappedBy가 없음!
- 일대다 양방향 매핑이 아예 불가능한 것은 아니라서, 일대다 단방향 매핑의 반대편인 "다"측에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 됨!!

간단하게 저장하고 조회하는 결과는 다대일 양방향과 유사하지만, 연관관계의 주인이 1측이라는 점과, 관리의 번거로움이 존재한다
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@NoArgsConstructor  
@AllArgsConstructor  
@Getter  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "team_table_generator",  
        table ="team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
  
    @OneToMany(mappedBy = "team")  
    private List<Member> members = new ArrayList<>();  
  
  
    public void addMember(Member member){  
        this.members.add(member);  
  
        //무한루프에 빠지지 않도록 체크  
  if(member.getTeam()!=this){  
            member.setTeam(this);  
        }  
    }  
}
```
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@NoArgsConstructor  
@AllArgsConstructor  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    //읽기전용  
  @ManyToOne  
 @JoinColumn(name ="team_id",insertable = false,updatable = false)//fk키값  
  @ToString.Exclude  
  private Team team;  
  
    public void setTeam(Team team){  
        if(this.team != null){  
            this.team.getMembers().remove(this);//지금 member와 연결 초기화  
  }  
  
        this.team = team;  
        this.team.getMembers().add(this);  
    }  
}
```

```java
package com.example.ch06jpastart9.test;  
  
import com.example.ch06jpastart9.domain.entity.Member;  
import com.example.ch06jpastart9.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("member1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("member2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
        List<Member> findByTeam = findTeam.getMembers();  
        System.out.println("team으로 접근된 members: "+findByTeam);  
  
        Member findMember = entityManager.find(Member.class,1L);  
        Team findByMember = findMember.getTeam();  
        System.out.println("member로 접근된 team: "+findByMember);  
    }  
}
```

```
01:31:50.486 [main] DEBUG org.hibernate.loader.collection.plan.AbstractLoadPlanBasedCollectionInitializer - Done loading collection
team으로 접근된 members: [Member(id=1, username=member1), Member(id=2, username=member2)]
member로 접근된 team: Team(id=1, name=team1, members=[Member(id=1, username=member1), Member(id=2, username=member2)])
```
🧡 될 수 있으면, 다대일 양방향 매핑을 이용하자!

## 3. 일대일

- 반대방향도 일대일
- 주테이블이나 대상 테이블 중 어느 곳이나 외래키를 가질 수 있다는 점이 일대다/다대일과의 차이점!

1️⃣ 주 테이블에 외래키

- 주 테이블에 외래키를 두고, 대상 테이블을 참조
- 객체 지향 개발자들이 선호하는 방식
- 장점: 주 테이블만 확인해도 대상 테이블과의 연관관계 존재여부를 확인 가능

2️⃣ 대상 테이블에 외래키

- 대상 테이블에 외래키를 두는 방식
- 전통적인 DB 개발자들이 선호하는 방식
- 장점: 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지 가능

### 3-1. 주 테이블에 외래키

#### 3-1-1. 주 테이블에 외래키-단방향

