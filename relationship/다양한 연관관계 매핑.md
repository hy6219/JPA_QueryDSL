
# 다양한 연관관계 매핑

### 💛 엔티티 연관관계 매핑 시 고려해야 할 요소들 💛

✅ 다중성

- 다대일(@ManyToOne)
- 일대다(@OneToMany)
- 일대일(@OneToOne)
- 다대다(@ManyToMany) - 거의 사용하지 않음

▶ 다중성을 판단하기 어려울 경우, 상대방측을 고려해서 판단하면 도움이 될 수 있음

✅ 단방향, 양방향

테이블은 외래키 하나로 양방향으로 쿼리가 가능하므로 방향이라는 개념이 없지만,
`객체`는 참조용 필드를 갖고 있는 객체만 연관된 객체를 조회할 수 있어서 `방향`이라는 개념이 존재!!

- `단방향` : 객체 관계에서 한 쪽만 참조하는 것
- `양방향` : 양쪽이 서로 참조하는 것

✅ 연관관계의 주인

- 양방향 관계에서 `외래키를 관리하는 측`
- 연관관계의 주인이 아닌 측에서는 읽기만 가능하고,
연관관계의 주인만이 외래키를 변경하고 읽을 수도 있음!!
- `연관관계 주인은 mappedBy 속성을 사용하지 않음`
- `연관관계의 주인이 아닌 곳에서` mappedBy속성으로 주인측에서의 변수명으로 관계를 맺어준다!!

## 1. 다대일(@ManyToOne)

- 다대일의 반대방향 : `항상 일대다`!!
(반대로, 일대다의 반대방향은 "다대일"~)

- `항상 연관관계의 주인은 다측!!`

### 1-1. 다대일 단방향

![다대일 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EB%8B%A8%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

위와 같이 Member 내부에 Team이 존재하고, Team 내부에는 Member가 없는 단방향 관계를 생각해보자
```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
  
    @ManyToOne  
 @JoinColumn(name = "team_id")  
    private Team team;  
}
```

```java
package com.example.ch06jpastart6.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name ="team_id")//이부분 미지정시 Team.id로 인식!!  
  private Long id;  
  
    private String name;  
}
```

```java
package com.example.ch06jpastart6.test;  
  
import com.example.ch06jpastart6.domain.entity.Member;  
import com.example.ch06jpastart6.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setTeam(team);  
        entityManager.persist(member);  
  
        Member findMember =  
                entityManager.find(Member.class,2L);  
  
        Team findTeam = findMember.getTeam();  
  
        System.out.println("find team: "+findTeam);  
    }  
}
```

그러면 아래처럼 Member를 통해 Team 정보를 확인해볼 수 있다
```
00:23:13.139 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 2, using strategy: org.hibernate.id.enhanced.SequenceStyleGenerator
find team: Team(id=1, name=team1)
```

### 1-2. 다대일 양방향

![다대일 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EC%9D%BC%EC%96%91%EB%B0%A9%ED%96%A5_6%EC%9E%A5.jpg?raw=true)

이번에는 위와 같이 Member와 Team 각각 내부에 각자에 대한 참조 필드를 마련해두고, 단 다측인 Member에서 FK를 관리하도록 하는 양방향 관계를 살펴보자
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @ManyToOne  
 @JoinColumn(name ="team_id")//상대측 id  private Team team;  
  
    public void setTeam(Team team1){  
        //변경되는 관계를 위한 초기화  
  if(this.team !=null){  
            this.team.getMembers().remove(this);  
        }  
        this.team = team1;  
        team.getMembers().add(this);  
    }  
}
```
```java
package com.example.ch06jpastart7.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name = "team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToMany(mappedBy = "team")//상대방인 Team이 나Member측에서 뭐라고 불리는지를 mappedBy에 맺어줌  
  //StackOverflowError를 막기 위함  
  @ToString.Exclude  
  private List<Member> members = new ArrayList<>();  
}
```
IDENTITY 전략을 사용한 이유는 , auto전략을 사용하면 자체적으로 hibernate_sequence가 공유되어 a 엔티티와 b엔티티에서 같이 사용되어 혼재될 수 있어서 선택하였는데
MySQL을 생각하던 중 identity 전략을 생각하게 되었다
하지만, table 전략도 괜찮을 것 같다
```java
package com.example.ch06jpastart7.test;  
  
import com.example.ch06jpastart7.domain.entity.Member;  
import com.example.ch06jpastart7.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToOneBiDirTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory=  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager=  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("mem1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("mem2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
  
        System.out.println("find members by team: "+findTeam.getMembers());  
        //member에서 team을 다시 확인해보기  
  findTeam.getMembers().forEach(member -> {  
            System.out.println("team->members->team: "+member.getTeam());  
        });  
    }  
}
```

위와 같이 Team을 찾고, 이를 이용해서 Member들을 찾을 수 있고, 이 member들 각각에서도 Team을 알아볼 수 있다
```
16:26:37.511 [main] DEBUG org.hibernate.resource.jdbc.internal.ResourceRegistryStandardImpl - HHH000387: ResultSet's statement was not registered
find members by team: [Member(id=1, username=mem1, team=Team(id=1, name=team1)), Member(id=2, username=mem2, team=Team(id=1, name=team1))]
team->members->team: Team(id=1, name=team1)
team->members->team: Team(id=1, name=team1)
```
그리고 위에서 볼 수 있는 점은 Members.team이 연관관계의 주인이기 때문에 setTeam으로 외래키를 변경할 수 있는 모습을 확인해볼 수 있다

🧡 그리고!! 위에서 본 것처럼 양방향 연관관계는 항상 서로를 참조해야 한다!!


## 2. 일대다

### 2-1. 일대다 단방향

- 일대다 단방향은 JPA 2.0부터 지원
![일대다 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

⚠ `일대다` 에서 `1` 측에서 FK를 관리!

- `@JoinColumn(name = 다측에서의 fk 키 이름)` 으로 맺어주어서 중간테이블 생성이 일어나지 않도록 하기
- 항상 외래키는 `다`측에서 존재하기 때문에, 실제 db에서는 MEMBER 측에 외래키 TEAM_ID가 존재한다
하지만, 객체에서 Member측에서는 외래키를 매핑할 수 있는 참조필드가 없어서 대신에 Team엔티티측에서의 Team.members로 참조하게 됨으로써
`연관관계 주인의 반대측`에서 외래키를 관리하게 되는 모습이 보이게 된다!!

▶ `일대다 단방향`의 단점!!

- 엔티티 저장과 연관관계 처리를 insert sql 외에 update sql을 추가적으로 실행해야!!

```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
  
@Entity  
@Data  
@TableGenerator(  
        name = "member_seq_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_seq_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    private String username;  
}
```
```java
package com.example.ch06jpastart8.domain.entity;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Data  
@TableGenerator(  
        name ="team_table_generator",  
        table = "team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
@NoArgsConstructor  
@AllArgsConstructor  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    private String name;  
  
    //일대다 단방향  
  @OneToMany  
 @JoinColumn(name = "team_id")//member 테이블의 fk  private List<Member> members = new ArrayList<>();  
}
```
```java
package com.example.ch06jpastart8.test;  
  
import com.example.ch06jpastart8.domain.entity.Member;  
import com.example.ch06jpastart8.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    public static void logic(EntityManager entityManager){  
        Member member1= new Member();  
        member1.setUsername("member1");  
        entityManager.persist(member1);  
  
        Member member2=new Member();  
        member2.setUsername("member2");  
        entityManager.persist(member2);  
  
        Team team = new Team();  
        team.setName("team1");  
        team.setMembers(List.of(member1,member2));  
        entityManager.persist(team);  
    }  
}
```
먼저 위와 같이 연관관계에 놓여진 두 엔티티를 만들고, 영속성 컨텍스트로 관리하게 되면, 아래와 같이 update sql이 추가적으로 실행되는 것을 확인해볼 수 있다

```
19:57:25.360 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.366 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
19:57:25.368 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Team
        (name, team_id) 
    values
        (?, ?)
19:57:25.371 [main] DEBUG org.hibernate.persister.collection.AbstractCollectionPersister - Inserting collection: [com.example.ch06jpastart8.domain.entity.Team.members#1]
19:57:25.371 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
19:57:25.372 [main] DEBUG org.hibernate.SQL - 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
Hibernate: 
    update
        Member 
    set
        team_id=? 
    where
        member_id=?
```

위의 경우를 다시 풀어서 정리해보면, 

- 처음에는 연관관계에 대한 정보를 Team.members 가 관리하기 때문에 Member 엔티티를 저장할 때는 Member 테이블의 TEAM_ID 외래키에 아무런 값도 저장되지 않는다!
- 대신, TEAM 엔티티를 저장할 때 Team.members의 참조값을 확인해서 MEMBER 테이블에 있는 TEAM_ID 외래키를 업데이트 하는 모습을 알 수 있다! 

💛 이렇듯, 일대일 단방향은 성능문제도 있지만, 관리도 부담스럽기 때문에(db 작업량뿐 아니라, fk 관리가 번거로움) `일대다 단방향 매핑 대신, 다대일 양방향 매핑을 사용하는 것`이  보다 권장된다!


### 2-2. 일대다 양방향
![일대다 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EB%8B%A4%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 일대다 양방향 매핑은 존재하지 않는 대신, `다대일 양방향 매핑`을 사용해야 함!!
- 1:N, N:1에서 연관관계의 주인은 항상 `다`측!! `@ManyToOne`을 사용한 측!!
▶ @ManyToOne을 사용한 측에는 mappedBy가 없음!
- 일대다 양방향 매핑이 아예 불가능한 것은 아니라서, 일대다 단방향 매핑의 반대편인 "다"측에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 됨!!

간단하게 저장하고 조회하는 결과는 다대일 양방향과 유사하지만, 연관관계의 주인이 1측이라는 점과, 관리의 번거로움이 존재한다
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@NoArgsConstructor  
@AllArgsConstructor  
@Getter  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "team_table_generator",  
        table ="team_sequences",  
        pkColumnValue = "team_seq",  
        allocationSize = 1  
)  
public class Team {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "team_table_generator")  
    @Column(name ="team_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
  
    @OneToMany(mappedBy = "team")  
    private List<Member> members = new ArrayList<>();  
  
  
    public void addMember(Member member){  
        this.members.add(member);  
  
        //무한루프에 빠지지 않도록 체크  
  if(member.getTeam()!=this){  
            member.setTeam(this);  
        }  
    }  
}
```
```java
package com.example.ch06jpastart9.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@NoArgsConstructor  
@AllArgsConstructor  
@ToString  
@EqualsAndHashCode  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    //읽기전용  
  @ManyToOne  
 @JoinColumn(name ="team_id",insertable = false,updatable = false)//fk키값  
  @ToString.Exclude  
  private Team team;  
  
    public void setTeam(Team team){  
        if(this.team != null){  
            this.team.getMembers().remove(this);//지금 member와 연결 초기화  
  }  
  
        this.team = team;  
        this.team.getMembers().add(this);  
    }  
}
```

```java
package com.example.ch06jpastart9.test;  
  
import com.example.ch06jpastart9.domain.entity.Member;  
import com.example.ch06jpastart9.domain.entity.Team;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class OneToManyBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        Team team = new Team();  
        team.setName("team1");  
        entityManager.persist(team);  
  
        Member member1 = new Member();  
        member1.setUsername("member1");  
        member1.setTeam(team);  
        entityManager.persist(member1);  
  
        Member member2 = new Member();  
        member2.setUsername("member2");  
        member2.setTeam(team);  
        entityManager.persist(member2);  
  
        Team findTeam = entityManager.find(Team.class,1L);  
        List<Member> findByTeam = findTeam.getMembers();  
        System.out.println("team으로 접근된 members: "+findByTeam);  
  
        Member findMember = entityManager.find(Member.class,1L);  
        Team findByMember = findMember.getTeam();  
        System.out.println("member로 접근된 team: "+findByMember);  
    }  
}
```

```
01:31:50.486 [main] DEBUG org.hibernate.loader.collection.plan.AbstractLoadPlanBasedCollectionInitializer - Done loading collection
team으로 접근된 members: [Member(id=1, username=member1), Member(id=2, username=member2)]
member로 접근된 team: Team(id=1, name=team1, members=[Member(id=1, username=member1), Member(id=2, username=member2)])
```
🧡 될 수 있으면, 다대일 양방향 매핑을 이용하자!

## 3. 일대일

- 반대방향도 일대일
- 주테이블이나 대상 테이블 중 어느 곳이나 외래키를 가질 수 있다는 점이 일대다/다대일과의 차이점!

1️⃣ 주 테이블에 외래키

- 주 테이블에 외래키를 두고, 대상 테이블을 참조
- 객체 지향 개발자들이 선호하는 방식
- 장점: 주 테이블만 확인해도 대상 테이블과의 연관관계 존재여부를 확인 가능

2️⃣ 대상 테이블에 외래키

- 대상 테이블에 외래키를 두는 방식
- 전통적인 DB 개발자들이 선호하는 방식
- 장점: 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지 가능

### 3-1. 주 테이블에 외래키

#### 3-1-1. 주 테이블에 외래키-단방향
![주 테이블에 외래키가 있는 경우- 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EC%A3%BC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 현재 위와 같이 FK가 주테이블인 Member 테이블에 있는 경우,

1️⃣ `주테이블에 해당되는 엔티티측`에 `@OneToOne` 을 붙이기

2️⃣ `주테이블에 해당되는 엔티티측`에 `@JoinColumn` 을 붙이기

3️⃣ 다대일 단방향과 유사(FK 를 관리하는 측에서 참조필드를 관리)

위와 같은 특징이 있다

간단하게 위와 동일하게 엔티티를 만들고, 저장 및 조회를 진행해보자

```java
package com.example.ch06jpastart10.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
}
```
```java
package com.example.ch06jpastart10.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToOne  
 @JoinColumn(name ="locker_id")  
    @Setter  
  private Locker locker;//일대일 연관관계  
}
```
```java
package com.example.ch06jpastart10.test;  
  
import com.example.ch06jpastart10.domain.entity.Locker;  
import com.example.ch06jpastart10.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
/**  
 * @author gs813  
 * 일대일 주테이블에 외래키가 있는 경우-단방향  
  */  
public class OneToOneMainUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        Locker locker = new Locker();  
        locker.setName("locker1");  
        entityManager.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setLocker(locker);  
        entityManager.persist(member);  
    }  
  
    static void search(EntityManager entityManager){  
        Member findMember = entityManager.find(Member.class,1L);  
        System.out.println("find 1L member: "+findMember);  
        System.out.println("find locker by member: "+findMember.getLocker());  
    }  
}
```
```
16:04:39.136 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists Locker CASCADE 
Hibernate: 
    
    drop table if exists Locker CASCADE 
16:04:39.138 [main] INFO org.hibernate.orm.connections.access - HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@2cc75074] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
16:04:39.139 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists locker_sequences CASCADE 
Hibernate: 
    
    drop table if exists locker_sequences CASCADE 
16:04:39.139 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists Member CASCADE 
Hibernate: 
    
    drop table if exists Member CASCADE 
16:04:39.144 [main] DEBUG org.hibernate.SQL - 
    
    drop table if exists member_sequences CASCADE 
Hibernate: 
    
    drop table if exists member_sequences CASCADE 
16:04:39.150 [main] DEBUG org.hibernate.SQL - 
    
    create table Locker (
       locker_id bigint not null,
        name varchar(255),
        primary key (locker_id)
    )
Hibernate: 
    
    create table Locker (
       locker_id bigint not null,
        name varchar(255),
        primary key (locker_id)
    )
16:04:39.150 [main] INFO org.hibernate.orm.connections.access - HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@6325f352] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
16:04:39.153 [main] DEBUG org.hibernate.SQL - 
    
    create table locker_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    create table locker_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
16:04:39.155 [main] DEBUG org.hibernate.SQL - 
    
    insert into locker_sequences(sequence_name, next_val) values ('locker_seq',0)
Hibernate: 
    
    insert into locker_sequences(sequence_name, next_val) values ('locker_seq',0)
16:04:39.158 [main] DEBUG org.hibernate.SQL - 
    
    create table Member (
       member_id bigint not null,
        username varchar(255),
        locker_id bigint,
        primary key (member_id)
    )
Hibernate: 
    
    create table Member (
       member_id bigint not null,
        username varchar(255),
        locker_id bigint,
        primary key (member_id)
    )
16:04:39.160 [main] DEBUG org.hibernate.SQL - 
    
    create table member_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    create table member_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
16:04:39.163 [main] DEBUG org.hibernate.SQL - 
    
    insert into member_sequences(sequence_name, next_val) values ('member_seq',0)
Hibernate: 
    
    insert into member_sequences(sequence_name, next_val) values ('member_seq',0)
16:04:39.164 [main] DEBUG org.hibernate.SQL - 
    
    alter table Member 
       add constraint FKmb6i4bdpv6jlenq04hjefd41v 
       foreign key (locker_id) 
       references Locker
Hibernate: 
    
    alter table Member 
       add constraint FKmb6i4bdpv6jlenq04hjefd41v 
       foreign key (locker_id) 
       references Locker
16:04:39.329 [main] DEBUG org.hibernate.SQL - 
    select
        tbl.next_val 
    from
        locker_sequences tbl 
    where
        tbl.sequence_name=? for update
            
Hibernate: 
    select
        tbl.next_val 
    from
        locker_sequences tbl 
    where
        tbl.sequence_name=? for update
            
16:04:39.332 [main] DEBUG org.hibernate.SQL - 
    update
        locker_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
Hibernate: 
    update
        locker_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?

16:04:39.357 [main] DEBUG org.hibernate.SQL - 
    select
        tbl.next_val 
    from
        member_sequences tbl 
    where
        tbl.sequence_name=? for update
            
Hibernate: 
    select
        tbl.next_val 
    from
        member_sequences tbl 
    where
        tbl.sequence_name=? for update
            
16:04:39.359 [main] DEBUG org.hibernate.SQL - 
    update
        member_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
Hibernate: 
    update
        member_sequences 
    set
        next_val=?  
    where
        next_val=? 
        and sequence_name=?
16:04:39.362 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
find 1L member: Member(id=1, username=member1, locker=Locker(id=1, name=locker1))
find locker by member: Locker(id=1, name=locker1)
16:04:39.427 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Locker
        (name, locker_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Locker
        (name, locker_id) 
    values
        (?, ?)
16:04:39.460 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (locker_id, username, member_id) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        Member
        (locker_id, username, member_id) 
    values
        (?, ?, ?)

```

그 결과, 위와 같이 Member를 통해 Locker를 확인할 수 있음을 알 수 있다
💙 `SELECT FOR UPDATE`
https://jaenjoy.tistory.com/28

- 조회된 row 에 대해서는 트랜잭션이 종료(commit, rollback) 되기 전까지 모든 crud가 차단되는 것

💚 행단위 ,테이블 단위 잠금

1️⃣ 테이블 단위 잠금 Table Level Locking

- 테이블 전체에 대한 접근 차단
- 같은 시간에 유입된 사용자가 요청한 동일 테이블의 다른 row에 대한 요청도 못받기 때문에 동시성 문제 해결에는 부적합

2️⃣ 행 단위 잠금 Row Level Locking

- 한 테이블 내에서 하나의 행에 대한 접근만 차단

✅ MySQL 기본 isolation level : Repeatable read

✅ Oracle 기본 isolation level : Read Committed

⚠ 트랜잭션 고립화 수준 Isolation level
reference: [구루비 트랜잭션 수준 읽기 일관성](http://wiki.gurubee.net/pages/viewpage.action?pageId=21200923#:~:text=%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EC%88%98%EC%A4%80%20%EC%9D%BD%EA%B8%B0%20%EC%9D%BC%EA%B4%80%EC%84%B1(%20Transaction,%EC%9D%BD%EC%96%B4%20%EB%93%A4%EC%9D%B4%EB%8A%94%20%EA%B2%83%EC%9D%84%20%EB%A7%90%ED%95%9C%EB%8B%A4.&text=%EC%9E%88%EC%9D%84%20%EC%88%98%20%EC%9E%88%EB%8B%A4.,%EC%9D%80%20%EC%9D%BD%EC%9D%84%20%EC%88%98%20%EC%9E%88%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4.)


[트랜잭션 고립화 수준, 발생가능한 현상, 트랜잭션 회복기법](https://rebro.kr/165) ▶ 회복기법은 다음에 꼭 읽고 정리하기!!

- isolation level  ⬆ ▶ 일관성(consistency)⬆&& 동시성(concurrency)⬇

1. 레벨 0 : Read Uncommitted

- 트랜잭션에서 처리 중인(=아직 커밋되지 않은) 데이터를 다른 트랜잭션에서 읽는 것을 허용
- Dirty read, Non-repeatable read, Phantom read 현상 발생
- 오라클 미지원

2. 레벨 1: Read Committed

- 커밋되어 확정된 데이터만 읽기
- Dirty read 방지
- 대부분의 RDBMS가 채택
- Non-Repeatable Read, Phantom Read 발생 가능

3. 레벨 2: Repeatable Read

- 선행 트랜잭션이 읽은 데이터는 해당 트랜잭션이 종료되기(commit, rollback) 전까지 `후행 트랜잭션이 갱신하거나 삭제하는 것을 불허`해서 데이터의 일관성을 유지
- Phantom read 현상 발생 가능
- Oracle : for update절로 접근 가능
- Phantom Read 발생 가능

4. 레벨 3 : Serializable Read

-   신형 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 산입하는 것도 막아줌

-   완벽하게 읽기 일관성 모드를 제공

💘 고립화 수준에 따라 발생할 수 있는 현상

1️⃣ Dirty Read

- 아직 커밋되지 않은 데이터를 다른 트랜잭션에서 읽을 경우 발생

2️⃣ Non-Repeatable Read

- 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, `그 사이 다른 트랜잭션이 값을 수정하거나 삭제함`으로써  `쿼리 실행 결과가 상이하게 나타나는 현상`

3️⃣ Phantom Read

- 한 트랜잭션 내에서 같은 데이터를 두 번  이상 읽을 때, `다른 트랜잭션이 중간에 값을 추가`함으로써 `첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 발생` 하는 현상

#### 3-1-2. 주 테이블에 외래키-양방향

![주 테이블에 외래키가 있는 경우 - 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EC%A3%BC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 이번에는 위의 `주 테이블에 외래키가 있는 경우- 단방향` 에 `반대방향을 추가` 해서 양방향으로 생각, 접근해보자
- 주테이블이 연관관계의 주인이기 때문에,

1️⃣ 주테이블

- @OneToOne
- @JoinColumn(name = fk 명)

2️⃣ 대상테이블

- @OneToOne(mappedBy = 대상테이블이 주테이블측에서 불리고 있는 필드명)

위를 참고해서 주테이블에 외래키가 있을 경우 단방향에 반대방향을 추가해서 확인해보자! 단, 오버플로우 에러 등을 막기 위해서 양측에 참조필드에 대해서 `@ToString.Exclude 를 붙여주자(사실 한쪽에만 붙여도 되지만, 양측에서 똑같이 적용해주고 싶어서 양측에 다 붙여주었다)`
```java
package com.example.ch06jpastart11.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {//대상테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToOne(mappedBy = "locker")//member.class에서 locker가 어떻게 되어있는지 확인  
  @Setter  
 @ToString.Exclude  private Member member;  
}
```

```java
package com.example.ch06jpastart11.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {//주테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
      
    @Setter  
  private String username;  
      
    @OneToOne  
 @JoinColumn(name ="locker_id")//연관관계 주인측(fk이름)  
  @Setter  
 @ToString.Exclude  private Locker locker;  
}
```

```java
package com.example.ch06jpastart11.test;  
  
import com.example.ch06jpastart11.domain.entity.Locker;  
import com.example.ch06jpastart11.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class OneToOneMainBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        Locker locker = new Locker();  
        locker.setName("locker1");  
        entityManager.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member1");  
        member.setLocker(locker);  
        entityManager.persist(member);  
  
        //양방향이므로 양측에서 관계 설정  
  locker.setMember(member);  
    }  
  
    static void search(EntityManager entityManager){  
        Locker findLocker = entityManager.find(Locker.class,1L);  
        Member findMember = entityManager.find(Member.class,1L);  
  
        System.out.println("Locker로 Member 정보 확인: [Locker: "+findLocker+"], member by locker: ["+findLocker.getMember()+"]");  
        System.out.println("Member로 Locker 정보 확인: [Member: "+findMember+"], locker by member: ["+findMember.getLocker()+"]");  
    }  
}
```

그러면 아래와 같이 양측에서 서로를 확인해볼 수 있음을 알 수 있다
```
00:43:13.673 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
Locker로 Member 정보 확인: [Locker: Locker(id=1, name=locker1)], member by locker: [Member(id=1, username=member1)]
Member로 Locker 정보 확인: [Member: Member(id=1, username=member1)], locker by member: [Locker(id=1, name=locker1)]
```

### 3-2. 대상 테이블에 외래키

#### 3-2-1. 대상 테이블에 외래키가 있는 경우- 단방향

![일대일 관계 - 대상 테이블에 외래키가 있는 경우의 단방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EB%8C%80%EC%83%81%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EB%8B%A8%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 이경우는 jpa에서 지원되지 않음(일대다 양방향도 원래는 지원되지 않는 것처럼! 하지만 일대다 양방향은 읽기 전용으로 만들어서 해결 가능)
- 1) 이 경우는 관계를 Locker에서 Member 방향으로 수정하거나,
- 2) 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야!

#### 3-2-2. 대상 테이블에 외래키가 있는 경우- 양방향

![일대일 관계 - 대상 테이블에 외래키가 있는 경우의 양방향](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EC%9D%BC%EB%8C%80%EC%9D%BC%EB%8C%80%EC%83%81%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90_%EC%99%B8%EB%9E%98%ED%82%A4_%EC%96%91%EB%B0%A9%ED%96%A5.jpg?raw=true)

- 일대일 매핑에서 대상 테이블에 FK를 두고 싶다면 `양방향`으로 매핑하고, 대상 엔티티를 연관관계의 주인으로 만들기

간단하게 두 엔티티를 만들어서 저장하고, 조회해보면 아래와 같이 양측에서 각각을 확인해볼 수 있음을 알 수 있다
```java
package com.example.ch06jpastart12.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "locker_table_generator",  
        table = "locker_sequences",  
        pkColumnValue = "locker_seq",  
        allocationSize = 1  
)  
public class Locker {//대상테이블->연관관계 주인으로 만들 것  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "locker_table_generator")  
    @Column(name ="locker_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @OneToOne  
 @JoinColumn(name = "member_id")  
    @Setter  
 @ToString.Exclude  private Member member;  
}
```

```java
package com.example.ch06jpastart12.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {//주테이블  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToOne(mappedBy = "member")//Member가 Locker에 어떻게 되어 있는지 지정(연관관계 주인이 Locker이므로 Member는 mappedBy로 받기)  
  @Setter  
 @ToString.Exclude  private Locker locker;  
}
```

```java
package com.example.ch06jpastart12.test;  
  
import com.example.ch06jpastart12.domain.entity.Locker;  
import com.example.ch06jpastart12.domain.entity.Member;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
/**  
 * @author gs813  
 * 대상테이블에 외래키가 있는 경우 양방향  
  * - 연관관계주인을 대상테이블로 하고 양방향으로 생각  
  */  
public class OneToOneAnotherSideBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager) {  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManagger) {  
        Locker locker = new Locker();  
        locker.setName("locker");  
        entityManagger.persist(locker);  
  
        Member member = new Member();  
        member.setUsername("member");  
        member.setLocker(locker);  
        entityManagger.persist(member);  
  
        locker.setMember(member);  
    }  
  
    static void search(EntityManager entityManager) {  
        Locker findLocker = entityManager.find(Locker.class, 1L);  
        Member findMember = entityManager.find(Member.class, 1L);  
  
        System.out.println("Locker로 Member 정보 확인: [Locker: " + findLocker + "], member by locker: [" + findLocker.getMember() + "]");  
        System.out.println("Member로 Locker 정보 확인: [Member: " + findMember + "], locker by member: [" + findMember.getLocker() + "]");  
    }  
}
```

```
01:15:48.454 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
Locker로 Member 정보 확인: [Locker: Locker(id=1, name=locker)], member by locker: [Member(id=1, username=member)]
Member로 Locker 정보 확인: [Member: Member(id=1, username=member)], locker by member: [Locker(id=1, name=locker)]
```

## 4. 다대다 관계

- RDBMS는 테이블 2개로 다대다 관계를 표현할 수 없지만, 객체는 객체 2개로 다대다 관계를 만들 수 있음!!

![다대다 연관관계](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EB%8B%A4%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84.jpg?raw=true)

### 4-1. 다대다 단방향

- 사실상 위의 개념으로 생각하면, Member_Product가 연관관계의 주인
- ✔ member 측에서 참조필드를 두고 생각하는 이유는? ➡ 찾아보고 정리할것!
- 🧡 `@JoinTable`을 사용해서 연결테이블을 바로 매핑

`@JoinTable`

- name 속성: 연결 테이블 지정
- joinColumns 속성 : 연결테이블에서 현재 방향인 엔티티와 매핑할 조인 컬럼 정보 지정
- inverseColumns: 연결테이블에서 반대방향인 엔티티와 매핑할 조인 컬럼 정보 지정

1️⃣ Member 측

- `@JoinTable(name = 연결테이블명, joinColumns=@JoinColumn(name = "연결테이블에서 현재 방향인 엔티티와 매핑할 조인 컬럼 정보 지정"), inverseJoinColumns=@JoinColumn(name = "연결테이블에서 반대방향인 엔티티와 매핑할 조인 컬럼 정보 지정")` 으로 연결테이블 없이 다대다 단방향 연관관계 설정

```java
package com.example.ch06jpastart13.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @ManyToMany  
 @JoinTable(  
            name = "member_product",  
            joinColumns = @JoinColumn(name = "member_id"),  
            inverseJoinColumns = @JoinColumn(name ="product_id")  
    )  
    @Setter  
  private List<Product> products = new ArrayList<>();  
  
}
```

2️⃣ Product 측

- Member 외 Product 필드들로 구성
```java
package com.example.ch06jpastart13.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="product_table_generator",  
        table = "product_sequences",  
        pkColumnValue = "product_seq",  
        allocationSize = 1  
)  
public class Product {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "product_table_generator")  
    @Column(name ="product_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @Setter  
  private int price;  
  
}
```

간단하게 Member 엔티티와 Product 엔티티를 만들어서 저장하고 조회해보자
```java
package com.example.ch06jpastart13.test;  
  
import com.example.ch06jpastart13.domain.entity.Member;  
import com.example.ch06jpastart13.domain.entity.Product;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class ManyToManyUniTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager) {  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager) {  
        Product productA = new Product();  
        productA.setPrice(1000);  
        productA.setName("새우깡");  
        entityManager.persist(productA);  
  
        Product productB = new Product();  
        productB.setPrice(1000);  
        productB.setName("옥수수깡");  
        entityManager.persist(productB);  
  
        Member member1 = new Member();  
        member1.setUsername("농심");  
        member1.setProducts(List.of(productA,productB));  
        entityManager.persist(member1);  
    }  
  
    static void search(EntityManager entityManager) {  
        Member findMember = entityManager.find(Member.class,1L);  
        List<Product> ref = findMember.getProducts();  
  
        ref.forEach(product -> {  
            System.out.println("member로 접근한 products: "+product);  
        });  
    }  
}
```
```
17:41:18.159 [main] DEBUG org.hibernate.SQL - 
    
    create table member_product (
       member_id bigint not null,
        product_id bigint not null
    )
    
 (중략)
 Hibernate: 
    
    alter table member_product 
       add constraint FKlblk4p5abv9vjdd18qg0nb8c7 
       foreign key (product_id) 
       references Product
17:41:18.172 [main] DEBUG org.hibernate.SQL - 
    
    alter table member_product 
       add constraint FK2w1s33jjs3ivlm5adyn9sg16u 
       foreign key (member_id) 
       references Member
       (중략)
17:41:18.362 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
member로 접근한 products: Product(id=1, name=새우깡, price=1000)
member로 접근한 products: Product(id=2, name=옥수수깡, price=1000)
(중략)
17:41:18.434 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Product
        (name, price, product_id) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        Product
        (name, price, product_id) 
    values
        (?, ?, ?)
17:41:18.441 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Product
        (name, price, product_id) 
    values
        (?, ?, ?)
Hibernate: 
    insert 
    into
        Product
        (name, price, product_id) 
    values
        (?, ?, ?)
17:41:18.442 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        Member
        (username, member_id) 
    values
        (?, ?)
17:41:18.446 [main] DEBUG org.hibernate.persister.collection.AbstractCollectionPersister - Inserting collection: [com.example.ch06jpastart13.domain.entity.Member.products#1]
17:41:18.446 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        member_product
        (member_id, product_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        member_product
        (member_id, product_id) 
    values
        (?, ?)
17:41:18.447 [main] DEBUG org.hibernate.SQL - 
    insert 
    into
        member_product
        (member_id, product_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        member_product
        (member_id, product_id) 
    values
        (?, ?)

```
그러면 위와 같이 중간테이블이 메모리 상에서 존재하게 되어 m:n 관계가 맺어질 수 있게 되고 , insert 작업이 진행될 수 있음을 확인해볼 수 있다

그리고 위에서 진행한 조회에서는 아래와 같은 조인을 기반으로 조회를 한 것과 다름없다

```sql
SELECT *
FROM  MEMBER_PRODUCT MP
INNER JOIN PRODUCT P ON MP.PRODUCT_ID = P.PRODUCT_ID
WHERE MP.MEMBER_ID=1
```

```sql
SELECT *
FROM  MEMBER_PRODUCT MP
INNER JOIN PRODUCT P USING(PRODUCT_ID)
WHERE MP.MEMBER_ID=1
```

### 4-2. 다대다 양방향

- 위의 다대다 단방향에서 역방향을 추가해주면 된다!!

1️⃣ Member 엔티티

- `@JoinTable` 이용

```java
package com.example.ch06jpastart14.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name ="member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @ManyToMany  
 @JoinTable(  
            name ="member_product",  
            joinColumns = @JoinColumn(name = "member_id"),  
            inverseJoinColumns = @JoinColumn(name ="product_id")  
    )  
    @ToString.Exclude  
 @Setter  private List<Product> products = new ArrayList<>();  
  
}
```

2️⃣ Product 엔티티

- mappedBy 속성 이용
```java
package com.example.ch06jpastart14.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name ="product_table_generator",  
        table = "product_sequences",  
        pkColumnValue = "product_seq",  
        allocationSize = 1  
)  
public class Product {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "product_table_generator")  
    @Column(name ="product_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
    @Setter  
  private int price;  
  
    //product가 member에서 무엇이라 불리는지 매칭  
  @ManyToMany(mappedBy = "products")  
    @ToString.Exclude  
 @Setter  private List<Member> members = new ArrayList<>();  
}
```

간단하게 두 엔티티를 저장하고 조회해보도록 하자
```java
package com.example.ch06jpastart14.test;  
  
import com.example.ch06jpastart14.domain.entity.Member;  
import com.example.ch06jpastart14.domain.entity.Product;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class ManyToManyBiTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        Product productA = new Product();  
        productA.setPrice(1000);  
        productA.setName("새우깡");  
        entityManager.persist(productA);  
  
        Product productB = new Product();  
        productB.setPrice(1000);  
        productB.setName("옥수수깡");  
        entityManager.persist(productB);  
  
        Member member1 = new Member();  
        member1.setUsername("농심");  
        member1.setProducts(List.of(productA,productB));  
        entityManager.persist(member1);  
  
        //양방향  
  productA.setMembers(List.of(member1));  
        productB.setMembers(List.of(member1));  
    }  
  
    static void search(EntityManager entityManager){  
        Member findMember = entityManager.find(Member.class,1L);  
        List<Product> ref = findMember.getProducts();//객체 그래프 탐색  
  
  ref.forEach(product -> {  
            System.out.println("member로 접근한 products: "+product);  
        });  
  
        Product findProduct = entityManager.find(Product.class,1L);  
        List<Member> members = findProduct.getMembers();  
  
        members.forEach(member->{  
            System.out.println("product로 접근한 members: "+member);  
        });  
    }  
}
```
```
18:33:09.538 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
member로 접근한 products: Product(id=1, name=새우깡, price=1000)
member로 접근한 products: Product(id=2, name=옥수수깡, price=1000)
product로 접근한 members: Member(id=1, username=농심)
```

그러면 양측에서 반대측 엔티티를 확인해볼 수 있는 것을 알 수 있다

### 4-3. 다대다: 매핑의 한계와 극복, 연결 엔티티 사용

`한계`

- 두 엔티티에 대한 id 외에 다른 필드들이 필요한 경우, 연결 테이블을 매핑하는 엔티티를 만들고, 참조 필드들을 관리해야!
- 별도의 컬럼이 추가되는 경우, 추가한 컬럼들을 매핑할 수 없어서 더 이상 @ManyToMany를 사용할 수 없음

![다대다 매핑의 한계](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EB%8B%A4%20%EB%A7%A4%ED%95%91%EC%9D%98%20%ED%95%9C%EA%B3%84.jpg?raw=true)

#### 4-3-1. 다대다 매핑의 한계 극복1- 복합키 클래스 사용

먼저, 내가 책에서 해당 부분에 대해서 이해/생각한 것은, 이번 경우 상품으로 회원을 접근하는 경우는 사용이 적고, 오히려 회원으로 접근하는 경우가 많아서

- member-member_product는 양방향
- member_product-product는 단방향
으로 구성한 것 같다고 생각했다(제 개인적 생각일 뿐입니다)

![다대다 매핑의 한계 - 연결 엔티티](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EB%8B%A4%20%EB%A7%A4%ED%95%91%EC%9D%98%20%ED%95%9C%EA%B3%84%20%EA%B7%B9%EB%B3%B51.jpg?raw=true)

이러한 상황을 구현해보자

- member / product 입장에서 member_product 내에서의 기록은 여러개일 수 있음 ➡ OneToMany(member / product- member_product)

➡ `member, product에 대한 키를 복합키 클래스로` 관리

1️⃣ 복합키를 별도의 클래스로 만들기

2️⃣ Serializable을 구현

3️⃣ equals, hashCode 메서드 구현

4️⃣ 기본 생성자가 있어야

5️⃣ 식별자 클래스는 public

6️⃣ @IdClass, @EmbeddedId를 이용해서 복합키 클래스를 활용하기

- 식별 관계 : 부모 테이블의 기본키를 받아서 `자신의 기본키+외래키`로 사용하는 것
➡ 현재 member_product가 해당
- 비식별 관계: `부모 테이블로부터 물려받은 기본키는 외래키로만` 사용

1) 복합키 클래스
```java
package com.example.ch06jpastart15.domain.entity;  
  
import lombok.EqualsAndHashCode;  
import lombok.NoArgsConstructor;  
import lombok.Setter;  
  
import java.io.Serializable;  
  
/**  
 * 복합키 클래스  
  * - serializable,기본 생성자, equals,hashCode 가져야!  
 * - 식별자 클래스는 public!!  
 */@NoArgsConstructor  
@Setter  
@EqualsAndHashCode  
public class MemberProductId implements Serializable {  
  
    private Long member;//MemberProduct.member와 연결  
  private Long product;//MemberProduct.product와 연결  
}
```

2) 복합키 클래스를 활용한 연결 엔티티

```java
package com.example.ch06jpastart15.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
//복합키 이용  
@IdClass(MemberProductId.class)  
public class MemberProduct {  
    @Id  
 @ManyToOne 
 @JoinColumn(name ="member_id")  
 @Setter
    private Member member;  
  
    @Id  
 @ManyToOne 
 @JoinColumn(name = "product_id")  
 @Setter
    private Product product;  
  
    @Setter
    private int orderAmount;  
}
```

3) Member 엔티티

```java
package com.example.ch06jpastart15.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToMany(mappedBy = "member")  
    @ToString.Exclude
    private List<MemberProduct> memberProducts = new ArrayList<>();  
}
```

4) Product 엔티티

```java
package com.example.ch06jpastart15.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "product_table_generator",  
        table = "product_sequences",  
        pkColumnValue = "product_seq",  
        allocationSize = 1  
)  
public class Product {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE,generator = "product_table_generator")  
    @Column(name = "product_id")  
    private Long id;  
  
    @Setter  
  private String name;  
}
```

간단하게 이러한 구성을 활용해서 데이터를 저장하고, 조회해보자

```java
package com.example.ch06jpastart15.test;  
  
import com.example.ch06jpastart15.domain.entity.Member;  
import com.example.ch06jpastart15.domain.entity.MemberProduct;  
import com.example.ch06jpastart15.domain.entity.MemberProductId;  
import com.example.ch06jpastart15.domain.entity.Product;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
public class ManyToManyMappingProSolvTest {  
    public static void main(String[] args) {  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        //회원 저장  
  Member member = new Member();  
        member.setUsername("member1");  
        entityManager.persist(member);  
  
        //상품 저장  
  Product product = new Product();  
        product.setName("product1");  
        entityManager.persist(product);  
  
        //회원상품 저장  
  MemberProduct memberProduct = new MemberProduct();  
        memberProduct.setMember(member);  
        memberProduct.setProduct(product);  
        memberProduct.setOrderAmount(3);  
        entityManager.persist(memberProduct);  
    }  
  
    static void search(EntityManager entityManager){  
        MemberProductId complexId = new MemberProductId();  
        complexId.setMember(1L);  
        complexId.setProduct(1L);  
  
        MemberProduct find = entityManager.find(MemberProduct.class,complexId);  
        Member member = find.getMember();  
        Product product = find.getProduct();  
  
        System.out.println("연결 엔티티로부터 접근한 member: "+member);  
        System.out.println("연결 엔티티로부터 접근한 product: "+product);  
    }  
}
```

그러면 이제 연결 엔티티인 MemberProduct로부터 Member, Product 정보를 확인해볼 수 있는 것을 알 수 있다

```
17:21:14.531 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: component[member,product]{product=1, member=1}, using strategy: org.hibernate.id.CompositeNestedGeneratedValueGenerator
연결 엔티티로부터 접근한 member: Member(id=1, username=member1)
연결 엔티티로부터 접근한 product: Product(id=1, name=product1)
```

이 방법에서 확인할 수 있는 것은, 복합키를 사용하기 때문에 ORM 매핑에서 처리해야할 일이

(1) 복합키를 위한 식별자 클래스를 생성
(2) equals, hashCode 구현 at 식별자 클래스

와 같이 복잡해진다는 단점이 존재한다는 것이다


#### 4-3-2. 다대다 매핑의 한계 극복2- 복합키 클래스 사용x!! 새로운 기본키 사용

이번에는 복합키 클래스를 사용하지 않고, 새로운 기본키로써 대리키를 활용해보자

![다대다 매핑의 한계 극복2-새로운 기본키 사용](https://github.com/hy6219/JPA_QueryDSL/blob/main/relationship/%EB%8B%A4%EB%8C%80%EB%8B%A4%20%EB%A7%A4%ED%95%91%EC%9D%98%20%ED%95%9C%EA%B3%84%20%EA%B7%B9%EB%B3%B52.jpg?raw=true)

이 경우, Order 테이블이 Member와 Product에 대해서는 외래키로 갖고, 자기자신의 기본키를 갖고 있기 때문에 `비식별` 관계로 구성되었음을 알 수 있다

이 경우, 

- Member- Order = 1:N (양방향; 서로를 조회)
- Order : Product = 1:N(단방향; Order에서만 관리해도 됨)

로 위에서와 같이 유사하게 구성해보자

1) OrderTable 엔티티(연결 엔티티)
`Syntax Error; expected "identifier"` 를 피하기 위해서 Order 대신 OrderTable 를 엔티티의 이름으로 채택하였다
```java
package com.example.ch06jpastart16.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.time.LocalDateTime;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "order_table_generator",  
        table = "order_sequences",  
        pkColumnValue = "order_seq",  
        allocationSize = 1  
)  
public class OrderTable {//연관관계의 주인  
  //sql 키워드때문에 OrderTable로 명칭변경  
  @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "order_table_generator")  
    @Column(name ="order_id")  
    private Long id;  
  
    @Setter  
  private int orderAmount;  
  
    @Setter  
  private LocalDateTime orderDate;  
  
    @ManyToOne  
 @JoinColumn(name = "member_id")  
    private Member member;  
  
    @ManyToOne  
 @JoinColumn(name ="product_id")  
    @Setter  
  private Product product;  
  
    public void setMember(Member member){  
        if(this.member != null){  
            this.member.getOrders().remove(this);  
        }  
        this.member = member;  
        this.member.getOrders().add(this);//역방향 적용  
  }  
  
    @PrePersist  
  public void setDefaultValue(){  
        if(this.orderDate == null){  
            this.setOrderDate(LocalDateTime.now());  
        }  
    }  
}
```

2) Member 엔티티
```java
package com.example.ch06jpastart16.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
import java.util.ArrayList;  
import java.util.List;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "member_table_generator",  
        table = "member_sequences",  
        pkColumnValue = "member_seq",  
        allocationSize = 1  
)  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "member_table_generator")  
    @Column(name = "member_id")  
    private Long id;  
  
    @Setter  
  private String username;  
  
    @OneToMany(mappedBy = "member")  
    @ToString.Exclude  
  private List<OrderTable> orders = new ArrayList<>();  
}
```

3) Product 엔티티

```java
package com.example.ch06jpastart16.domain.entity;  
  
import lombok.*;  
  
import javax.persistence.*;  
  
@Entity  
@Getter  
@ToString  
@EqualsAndHashCode  
@NoArgsConstructor  
@AllArgsConstructor  
@TableGenerator(  
        name = "product_table_generator",  
        table = "product_sequences",  
        pkColumnValue = "product_seq",  
        allocationSize = 1  
)  
public class Product {  
    @Id  
 @GeneratedValue(strategy = GenerationType.TABLE, generator = "product_table_generator")  
    @Column(name = "product_id")  
    private Long id;  
  
    @Setter  
  private String name;  
  
}
```

이번에도 간단하게 데이터를 저장하고 조회해보면, 연결 엔티티로 Member, Product 엔티티를 접근할 수 있음을 확인해볼 수 있다
```java
package com.example.ch06jpastart16.test;  
  
import com.example.ch06jpastart16.domain.entity.Member;  
import com.example.ch06jpastart16.domain.entity.OrderTable;  
import com.example.ch06jpastart16.domain.entity.Product;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
  
/**  
 * 새로운 기본키로 다대다 한계 극복  
  */  
public class ManyToManyUnidentifiableProSolvTest {  
    public static void main(String[] args) {  
  
        EntityManagerFactory entityManagerFactory =  
                Persistence.createEntityManagerFactory("jpabook");  
        EntityManager entityManager =  
                entityManagerFactory.createEntityManager();  
        EntityTransaction tx =  
                entityManager.getTransaction();  
  
        try {  
            tx.begin();  
            logic(entityManager);  
            tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            entityManager.close();  
        }  
        entityManagerFactory.close();  
    }  
  
    static void logic(EntityManager entityManager){  
        save(entityManager);  
        search(entityManager);  
    }  
  
    static void save(EntityManager entityManager){  
        //상품저장  
  Product product1 = new Product();  
        product1.setName("product1");  
        entityManager.persist(product1);  
  
        //회원저장  
  Member member1 = new Member();  
        member1.setUsername("member1");  
        entityManager.persist(member1);  
  
        //주문저장  
  OrderTable order = new OrderTable();  
        order.setOrderAmount(2);  
        order.setProduct(product1);  
        order.setMember(member1);//양방향 적용  
  entityManager.persist(order);  
    }  
  
    static void search(EntityManager entityManager){  
        OrderTable order = entityManager.find(OrderTable.class,1L);  
        Member member = order.getMember();  
        Product product = order.getProduct();  
  
        System.out.println("order로 접근한 member: "+member);  
        System.out.println("order로 접근한 product: "+product);  
    }  
}
```

```
Hibernate: 
    
    drop table if exists Member CASCADE 
Hibernate: 
    
    drop table if exists member_sequences CASCADE 
Hibernate: 
    
    drop table if exists order_sequences CASCADE 
Hibernate: 
    
    drop table if exists OrderTable CASCADE 
Hibernate: 
    
    drop table if exists Product CASCADE
Hibernate: 
    
    drop table if exists product_sequences CASCADE 
Hibernate: 
    
    create table Member (
       member_id bigint not null,
        username varchar(255),
        primary key (member_id)
    )
Hibernate: 
    
    create table member_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    insert into member_sequences(sequence_name, next_val) values ('member_seq',0)
Hibernate: 
    
    create table order_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
Hibernate: 
    
    insert into order_sequences(sequence_name, next_val) values ('order_seq',0)
Hibernate: 
    
    create table OrderTable (
       order_id bigint not null,
        orderAmount integer not null,
        orderDate timestamp,
        member_id bigint,
        product_id bigint,
        primary key (order_id)
    )
Hibernate: 
    
    create table Product (
       product_id bigint not null,
        name varchar(255),
        primary key (product_id)
    )
Hibernate: 
    
    create table product_sequences (
       sequence_name varchar(255) not null,
        next_val bigint,
        primary key (sequence_name)
    )
18:04:35.213 [main] DEBUG org.hibernate.SQL - 
    
    insert into product_sequences(sequence_name, next_val) values ('product_seq',0)
Hibernate: 
    
    alter table OrderTable 
       add constraint FKdt7ao9ijmiieexba2bmmamaq8 
       foreign key (member_id) 
       references Member
Hibernate: 
    
    alter table OrderTable 
       add constraint FKb9reudvwpoij9q1tt9hav2ef7 
       foreign key (product_id) 
       references Product
18:04:35.427 [main] DEBUG org.hibernate.event.internal.AbstractSaveEventListener - Generated identifier: 1, using strategy: org.hibernate.id.enhanced.TableGenerator
order로 접근한 member: Member(id=1, username=member1)
order로 접근한 product: Product(id=1, name=product1)
```

이 방식은 코드 작성이 이전의 복합키 활용보다 단순해진 것을 확인해볼 수 있다

🧡위와 같이 `다대다 관계`는 `별도 필드 존재 및 추가 시 더는 사용할 수 없기 때문에 일대다나 다대일 관계로 매핑하는 것이 권장된다`💛
