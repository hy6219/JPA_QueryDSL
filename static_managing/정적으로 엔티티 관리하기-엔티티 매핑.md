# 정적으로 엔티티 관리하기-엔티티 매핑

|역할  |어노테이션  |
|--|--|
|객체와 테이블 매핑  |@Entity,@Table  |
|기본키 매핑|@Id|
|필드와 컬럼 매핑|@Column|
|연관관계 매핑|@OneToOne,@ManyToOne, @OneToMany,@JoinColumn|
(이전에 공부했던 기억으로는, 일대다의 연관관계가 있을 때에는 @OneToMany보다는 @ManyToOne이 보다 깔끔하다고 공부했던 기억이 있다!)

## 01. 객체와 테이블 매핑

### 01-1. @Entity

이건 필수!! JPA가 관리하는 클래스임을 명시적으로 보여주는 것!!

[@Entity 속성]

-  name=~ :  JPA에서 사용할 엔티티 이름 지정
(대소문자를 구별하는 DB이면 조금은 주의할 필요가 있다!!)
(기본값: 클래스 이름으로 탐색)

[@Entity 적용시 주의사항]

1. 기본 생성자는 필수!(public, protected가 붙은 생성자)
2.  final 클래스, enum, interface, inner 클래스에는 사용할 수 없음
3. 저장할 필드에 final을 사용하면 안된다!

### 01-2. @Table

@Table을 생략하게 되면, 엔티티 이름을 테이블 이름으로 사용하게 된다!!

[@Table 속성 정리]

|속성  |기능  |기본값  |
|--|--|--|
|name  |매핑할 테이블 이름  |엔티티 이름을 활용  |
|catalog  |catalog 기능이 있는 db에서 catalog를 매핑  |  |
|schema  |schema 기능이 있는 db에서 catalog를 매핑  |  |
|uniqueConstraints(DDL)  |DDL 생성 시 유니크 제약조건을 만듦(스키마 자동생성 기능을 사용해서 DDL을 만들 때만 사용 가능)  |  |

#### 01-2-1. 다양한 매핑 사용

Member 테이블을 drop하고, 새로운 프로젝트를 만들자!
(ch04-jpa-start2 프로젝트)

Member.java로 엔티티 객체를 만들자

```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.Date;  
  
@Entity  
@Table(name="MEMBER")  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name="ID")  
    private Long id;  
  
  @Column(name="NAME")  
    private String name;  
  
  @Column(name="AGE")  
    private Integer age;  
  
  @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private Date createdAt;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private Date updatedAt;  
  
  @Lob  
  private String description;  
}
```

그리고! persistence.xml에 애플리케이션 실행 시점에 db 테이블을 자동으로 생성할 수 있도록 아래와 같은 설정을 추가해주자
`<property name="hibernate.hbm2ddl.auto" value="create"/>`

위의 이러한 속성은 `개발 서버나 개발 단계에서만` 사용하는 것이 적절하지, 운영 서버에서의 사용은 권장되지 않는다!

- 개발 초기 단계: create 또는 update
- 초기화 상태로 자동화된 테스트를 진행하는 개발자 환경과 CI 서버: create 또는 create-drop
- 테스트 서버: update 또는 validate
- 스테이징과 운영서버: validate 또는 none

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1">  
 <persistence-unit name="jpabook">  
         <properties>  
  <!--필수속성-->  
  <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>  
 <property name="javax.persistence.jdbc.user" value="sa"/>  
 <property name="javax.persistence.jdbc.password" value=""/>  
 <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>  
 <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>  
  
  <!--선택속성-->  
  <property name="hibernate.show_sql" value="true"/>  
 <property name="hibernate.format_sql" value="true"/>  
  <!--애플리케이션 실행 시점에 db 테이블을 자동으로 생성-->  
  <property name="hibernate.hbm2ddl.auto" value="create"/>  
 </properties> 
 </persistence-unit>
 </persistence>
```

위는  아래와 같은 테이블이 새로이 생성된 것과 같다고 간주하면 된다!

```sql
CREATE TABLE MEMBER(
  ID LONG PRIMARY KEY,
  NAME VARCHAR(255),
  AGE INTEGER,
  ROLETYPE VARCHAR(255),
  CREATEDAT TIMESTAMP,
  UPDATEDAT TIMESTAMP,
  DESCRIPTION CLOB
);

```
[hibernate.hbm2ddl.auto 속성]

|옵션|설명  |
|--|--|
|create  |기존 테이블을 삭제하고 새로 생성(DROP+CREATE)  |
|create-drop|create 속성에 추가로 애플리케이션 종료시 생성한 ddl을 제거(DROP+CREATE+DROP)|
|update|db 테이블과 엔티티 매핑정보를 비교해서 변경사항만 수정|
|validate|db테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고, 애플리케이션을 실행하지 않음! 이설정은 ddl을 수정하지 않음!|
|none|자동 생성 기능을 사용하지 않으려면 hibernate.hbm2ddl.auto 속성 자체를 삭제하거나 유효하지 않은 옵션값을 주면 된다는 뜻(none: 유효하지 않은 옵션값)|

✅ @Lob: CLOB, BLOB과 같은 타입을 매핑할 수 있음

✅ @Temporal : 자바의 날짜타입 매핑

- 속성값으로 value가 있고, 이는 TemporalType 형을 지닌다!
- 그리고 Temporal을 사용하는 필드의 타입은 Date여야만 한다!!
```
@Temporal should only be set on a java.util.Date or java.util.Calendar property
```
- 아래는 TemporalType에 대해서 정리된 enum이다
```java
/*  
 * Copyright (c) 2008, 2019 Oracle and/or its affiliates. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v. 2.0 which is available at * http://www.eclipse.org/legal/epl-2.0, * or the Eclipse Distribution License v. 1.0 which is available at * http://www.eclipse.org/org/documents/edl-v10.php. * * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause */  
// Contributors:  
//     Linda DeMichiel - 2.1  
//     Linda DeMichiel - 2.0  
  
package javax.persistence;  
  
/**  
 * Type used to indicate a specific mapping of <code>java.util.Date</code>   
 * or <code>java.util.Calendar</code>.  
 * * @since 1.0  
 */public enum TemporalType {  
  
    /** Map as <code>java.sql.Date</code> */  
  DATE,   
  /** Map as <code>java.sql.Time</code> */  
  TIME,   
  /** Map as <code>java.sql.Timestamp</code> */  
  TIMESTAMP  
}
```
크게 DATE, TIME,TIMESTAMP로 되어있다

 ➕ persistence.xml에서 이름매핑전략을 설정하는 방법은 아래와 같이 옵션을 추가해주면 된다!
 
org.hibernate.cfg.ImprovedNamingStrategy

▶ 자바의 카멜 표기법을 테이블의 언더바 표기법으로 변경해주는 클래스!!

```
<!--이름 매핑 전략-->  
<property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1">  
 <persistence-unit name="jpabook">  
         <properties>  
  <!--필수속성-->  
  <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>  
 <property name="javax.persistence.jdbc.user" value="sa"/>  
 <property name="javax.persistence.jdbc.password" value=""/>  
 <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>  
 <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>  
  
  <!--선택속성-->  
  <property name="hibernate.show_sql" value="true"/>  
 <property name="hibernate.format_sql" value="true"/>  
  <!--애플리케이션 실행 시점에 db 테이블을 자동으로 생성-->  
  <property name="hibernate.hbm2ddl.auto" value="create"/>  
  <!--이름 매핑 전략-->  
  <property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>  
 </properties> </persistence-unit></persistence>
 ```


### 01-3. DDL 생성 기능

@Column에 대해서 알아보기 위해서
Column 인터페이스를 분석해보자

```java
/*  
 * Copyright (c) 2008, 2019 Oracle and/or its affiliates. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v. 2.0 which is available at * http://www.eclipse.org/legal/epl-2.0, * or the Eclipse Distribution License v. 1.0 which is available at * http://www.eclipse.org/org/documents/edl-v10.php. * * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause */  
// Contributors:  
//     Linda DeMichiel - 2.1  
//     Linda DeMichiel - 2.0  
  
  
package javax.persistence;  
  
import java.lang.annotation.Target;  
import java.lang.annotation.Retention;  
import static java.lang.annotation.ElementType.METHOD;  
import static java.lang.annotation.ElementType.FIELD;  
import static java.lang.annotation.RetentionPolicy.RUNTIME;  
  
@Target({METHOD, FIELD})   
@Retention(RUNTIME)  
public @interface Column {  
  
  String name() default "";  

  boolean unique() default false;  
  
  boolean nullable() default true;  
  
  boolean insertable() default true;  

  boolean updatable() default true;  

  String columnDefinition() default "";  
  
  String table() default "";  
 
     int length() default 255;  
  
     int precision() default 0;  
  
     int scale() default 0;  
}
```

(1) name 속성

- 테이블의 어떤 컬럼명과 매핑할 것인지를 명시

(2) unique 속성

- 해당 속성이 고유키 제약조건에 해당하는지 t/f로 명시

(3) insertable 속성

- INSERT 쿼리에 해당 속성을 포함시킬 것인지를 t/f로 명시

(4) updatable 속성

- UPDATE 쿼리에 해당 속성을 포함시킬 것인지를 t/f로 명시

(5) nullable 속성

- 해당 속성이 null이어도 되는지를 t/f로 명시

(6) length 속성

- String 타입을 갖는 열에 대해서 길이를 지정(int 값이므로 최대 약 21억 크기까지 지정 가능)

etc...

---------

(1) 만약, 이름 속성에 대해서 NOT NULL이어야 하고, 최대 길이가 10글자를 넘어가면 안된다면 아래와 같이 지정해주면 된다!

```java
@Column(name="NAME",nullable = false, length = 10)  
private String name;
```
```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.Date;  
  
@Entity  
@Table(name="MEMBER")  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name="ID")  
    private Long id;  
  
  @Column(name="NAME",nullable = false, length = 10)  
    private String name;  
  
  @Column(name="AGE")  
    private Integer age;  
  
  @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private Date createdAt;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private Date updatedAt;  
  
  @Lob  
  private String description;  
}
```

이렇게 되면 아래와 같은 DDL이 실행된 것과 같다!

```sql
CREATE TABLE MEMBER(
	ID LONG PRIMARY KEY,
	NAME VARCHAR(10) NOT NULL,
	AGE INTEGER,
	ROLETYPE VARCHAR(255),
	CREATEDAT TIMESTAMP,
   UPDATEDAT TIMESTAMP,
   DESCRIPTION CLOB
);
```

(2) 만약 , 여기서 "name"과 "age" 컬럼에 대해서 고유키 제약조건을 걸고 싶다면? 

➕ UniqueConstraint 속성에는 어떤것이 있는지 확인하기

```java
package javax.persistence;  
  
import java.lang.annotation.Target;  
import java.lang.annotation.Retention;  
import static java.lang.annotation.RetentionPolicy.RUNTIME;  
  
@Target({})   
@Retention(RUNTIME)  
public @interface UniqueConstraint {  
  
  String name() default "";   

  String[] columnNames();  
}
```

- name 속성 : 제약조건명
- columnNames 속성: 어떤 컬럼(들)에 제약조건을 걸어줄 것인지 명시
```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.Date;  
  
@Entity  
@Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint(  
        name="NAME_AGE_UNIQUE",  
        columnNames = {"NAME","AGE"}  
)})  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name="ID")  
    private Long id;  
  
    @Column(name="NAME",nullable = false, length = 10)  
    private String name;  
  
    @Column(name="AGE")  
    private Integer age;  
  
    @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
    @Temporal(TemporalType.TIMESTAMP)  
    private Date createdAt;  
  
    @Temporal(TemporalType.TIMESTAMP)  
    private Date updatedAt;  
  
    @Lob  
  private String description;  
}
```
위와 같이 생각해볼 수 있고 이는 1번에서 확장해서 생각해본다면

```sql

CREATE TABLE MEMBER(
	ID LONG PRIMARY KEY,
	NAME VARCHAR(10) NOT NULL,
	AGE INTEGER,
	ROLETYPE VARCHAR(255),
	CREATEDAT TIMESTAMP,
   UPDATEDAT TIMESTAMP,
   DESCRIPTION CLOB
);

ALTER TABLE MEMBER
ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE(NAME,AGE);

```

와 같은 쿼리가 진행된다는 것을 연장해서 생각해볼 수 있다

그리고 (1) 이던지 (2) 이던지 이러한 모든 기능들은 단지 DDL을 자동 생성할때에만 생성되고, jpa의 실행 로직에는 영향을 주지 않는다!!

## 02. 기본키 매핑 전략

JPA에서 제공하는 DB 기본키 생성 전략

1. 직접 할당 : 기본키를 애플리케이션에서 직접 할당(@Id 만 사용해도 됨)
2. 자동 생성 : 대리 키 사용 방식(IDENTITY, SEQUENCE, TABLE)(@Id+@GeneratedValue(strategy=GenerationType.~))

➡ DB 벤더마다 지원하는 방식이 다르기 때문에 자동 생성 전략이 다양하다!!

✨ 키 생성 전략을 사용하고 싶다면, `persistence.xml`에 아래 속성을 추가하자!

```xml
<!--키 생성 전략-->  
<property name="hibernate.id.new_generator_mappings" value="true"/>
```
### 02-1. 기본키 매핑 전략- 직접 할당

`entityManager.persist(entity)` 실행 전, 애플리케이션에서 기본키를 직접 할당

```java
Board board=new Board();
board.setId(1);
em.persist(board);
```
이때, 직접 할당 방식에서 기본키를 지정하지 않으면, javax.persistence.PersistenceException예외가 발생되는데, 내부에는 org.hibernate.id.IdentifierGenerationException 예외를 포함하고 있다!!

✨ @Id 적용 가능 자바 타입 ✨

- primitive type
- 래퍼 클래스
- String
- java.util.Date, java.sql.Date
- java.math.BigDecimal
- java.math.BigInteger

### 02-2. 기본키 매핑 전략- 자동 생성

#### 02-2-1. IDENTITY 전략

- `기본키 생성을 DB에 위임`하는 전략
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
- `@GeneratedValue(strategy=GenerationType.IDENTITY)` 사용
- 엔티티를 DB에 저장해야 식별자를 구할 수 있기 때문에 쓰기 지연이 동작하지 않는다

```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.util.Date;  
  
@Entity  
@Table(name="MEMBER", uniqueConstraints = {@UniqueConstraint(  
        name="NAME_AGE_UNIQUE",  
        columnNames = {"NAME","AGE"}  
)})  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)  
    @Column(name="ID")  
    private Long id;  
  
    @Column(name="NAME",nullable = false, length = 10)  
    private String name;  
  
    @Column(name="AGE")  
    private Integer age;  
  
    @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
    @Temporal(TemporalType.TIMESTAMP)  
    private Date createdAt;  
  
    @Temporal(TemporalType.TIMESTAMP)  
    private Date updatedAt;  
  
    @Lob  
  private String description;  
}
```
위와 같이 IDENTITY 전략을 사용한 후, id값을 자동할당되도록 테스트해보자

```java
package com.example.ch04jpastart2.jpabook.start;  
  
import javax.persistence.EntityManager;  
import javax.persistence.EntityManagerFactory;  
import javax.persistence.EntityTransaction;  
import javax.persistence.Persistence;  
import java.util.List;  
  
public class IdentityStrategyTest {  
    //1.EntityManagerFactory 객체  
  static EntityManagerFactory emf=  
            Persistence.createEntityManagerFactory("jpabook");  
    //2,EntityManager 객체  
  static EntityManager em=  
            emf.createEntityManager();  
    //3.EntityTransaction 객체  
  static EntityTransaction tx=  
            em.getTransaction();  
  
    public static void main(String[] args) {  
        try{  
            //4.트랜잭션 시작  
  tx.begin();  
            //5.로직테스트  
  Member member=new Member();  
            member.setAge(20);  
            member.setName("가나다");  
            //영속성 컨텍스트로 등록  
  em.persist(member);  
            //모든 데이터 확인  
  List<Member> members=  
                    em.createQuery("select m from Member m",Member.class)  
                            .getResultList();  
            System.out.println("identity 자동 생성 전략 적용 후 확인: "+members);  
            //6.커밋  
  tx.commit();  
        }catch (Exception e){  
            e.printStackTrace();  
        }finally {  
            em.close();  
        }  
        emf.close();  
    }  
}
```

그러면 아래와 같이 기본키값이 자동할당된 모습을 확인해볼 수 있다

```
00:18:34.577 [main] DEBUG org.hibernate.internal.util.EntityPrinter - com.example.ch04jpastart2.jpabook.start.Member{createdAt=null, name=가나다, description=null, id=1, roleType=null, age=20, updatedAt=null}
```

#### 02-2-2. SEQUENCE 전략

- 유일한 값을 순서대로 생성하는 특별한 db 객체
- 오라클, PostgreSQL, DB2, H2 에서 지원
- `@GeneratedValue(strategy=GenerationType.SEQUENCE)` 를 활용


