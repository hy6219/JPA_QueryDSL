# 정적으로 엔티티 관리하기-엔티티 매핑

|역할  |어노테이션  |
|--|--|
|객체와 테이블 매핑  |@Entity,@Table  |
|기본키 매핑|@Id|
|필드와 컬럼 매핑|@Column|
|연관관계 매핑|@OneToOne,@ManyToOne, @OneToMany,@JoinColumn|
(이전에 공부했던 기억으로는, 일대다의 연관관계가 있을 때에는 @OneToMany보다는 @ManyToOne이 보다 깔끔하다고 공부했던 기억이 있다!)

## 01. 객체와 테이블 매핑

### 01-1. @Entity

이건 필수!! JPA가 관리하는 클래스임을 명시적으로 보여주는 것!!

[@Entity 속성]

-  name=~ :  JPA에서 사용할 엔티티 이름 지정
(대소문자를 구별하는 DB이면 조금은 주의할 필요가 있다!!)
(기본값: 클래스 이름으로 탐색)

[@Entity 적용시 주의사항]

1. 기본 생성자는 필수!(public, protected가 붙은 생성자)
2.  final 클래스, enum, interface, inner 클래스에는 사용할 수 없음
3. 저장할 필드에 final을 사용하면 안된다!

### 01-2. @Table

@Table을 생략하게 되면, 엔티티 이름을 테이블 이름으로 사용하게 된다!!

[@Table 속성 정리]

|속성  |기능  |기본값  |
|--|--|--|
|name  |매핑할 테이블 이름  |엔티티 이름을 활용  |
|catalog  |catalog 기능이 있는 db에서 catalog를 매핑  |  |
|schema  |schema 기능이 있는 db에서 catalog를 매핑  |  |
|uniqueConstraints(DDL)  |DDL 생성 시 유니크 제약조건을 만듦(스키마 자동생성 기능을 사용해서 DDL을 만들 때만 사용 가능)  |  |

#### 01-2-1. 다양한 매핑 사용

Member 테이블을 drop하고, 새로운 프로젝트를 만들자!
(ch04-jpa-start2 프로젝트)

Member.java로 엔티티 객체를 만들자

```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.time.LocalDateTime;  
  
@Entity  
@Table(name="MEMBER")  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name="ID")  
    private Long id;  
  
  @Column(name="NAME")  
    private String name;  
  
  @Column(name="AGE")  
    private Integer age;  
  
  @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private LocalDateTime createdAt;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private LocalDateTime updatedAt;  
  
  @Lob  
  private String description;  
}
```

그리고! persistence.xml에 애플리케이션 실행 시점에 db 테이블을 자동으로 생성할 수 있도록 아래와 같은 설정을 추가해주자
`<property name="hibernate.hbm2ddl.auto" value="create"/>`

위의 이러한 속성은 `개발 서버나 개발 단계에서만` 사용하는 것이 적절하지, 운영 서버에서의 사용은 권장되지 않는다!

- 개발 초기 단계: create 또는 update
- 초기화 상태로 자동화된 테스트를 진행하는 개발자 환경과 CI 서버: create 또는 create-drop
- 테스트 서버: update 또는 validate
- 스테이징과 운영서버: validate 또는 none

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1">  
 <persistence-unit name="jpabook">  
         <properties>  
  <!--필수속성-->  
  <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>  
 <property name="javax.persistence.jdbc.user" value="sa"/>  
 <property name="javax.persistence.jdbc.password" value=""/>  
 <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>  
 <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>  
  
  <!--선택속성-->  
  <property name="hibernate.show_sql" value="true"/>  
 <property name="hibernate.format_sql" value="true"/>  
  <!--애플리케이션 실행 시점에 db 테이블을 자동으로 생성-->  
  <property name="hibernate.hbm2ddl.auto" value="create"/>  
 </properties> 
 </persistence-unit>
 </persistence>
```

위는  아래와 같은 테이블이 새로이 생성된 것과 같다고 간주하면 된다!

```sql
CREATE TABLE MEMBER(
  ID LONG PRIMARY KEY,
  NAME VARCHAR(255),
  AGE INTEGER,
  ROLETYPE VARCHAR(255),
  CREATEDAT TIMESTAMP,
  UPDATEDAT TIMESTAMP,
  DESCRIPTION CLOB
);

```
[hibernate.hbm2ddl.auto 속성]

|옵션|설명  |
|--|--|
|create  |기존 테이블을 삭제하고 새로 생성(DROP+CREATE)  |
|create-drop|create 속성에 추가로 애플리케이션 종료시 생성한 ddl을 제거(DROP+CREATE+DROP)|
|update|db 테이블과 엔티티 매핑정보를 비교해서 변경사항만 수정|
|validate|db테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고, 애플리케이션을 실행하지 않음! 이설정은 ddl을 수정하지 않음!|
|none|자동 생성 기능을 사용하지 않으려면 hibernate.hbm2ddl.auto 속성 자체를 삭제하거나 유효하지 않은 옵션값을 주면 된다는 뜻(none: 유효하지 않은 옵션값)|

✅ @Lob: CLOB, BLOB과 같은 타입을 매핑할 수 있음

✅ @Temporal : 자바의 날짜타입 매핑

- 속성값으로 value가 있고, 이는 TemporalType 형을 지닌다!
- 아래는 TemporalType에 대해서 정리된 enum이다
```java
/*  
 * Copyright (c) 2008, 2019 Oracle and/or its affiliates. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v. 2.0 which is available at * http://www.eclipse.org/legal/epl-2.0, * or the Eclipse Distribution License v. 1.0 which is available at * http://www.eclipse.org/org/documents/edl-v10.php. * * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause */  
// Contributors:  
//     Linda DeMichiel - 2.1  
//     Linda DeMichiel - 2.0  
  
package javax.persistence;  
  
/**  
 * Type used to indicate a specific mapping of <code>java.util.Date</code>   
 * or <code>java.util.Calendar</code>.  
 * * @since 1.0  
 */public enum TemporalType {  
  
    /** Map as <code>java.sql.Date</code> */  
  DATE,   
  /** Map as <code>java.sql.Time</code> */  
  TIME,   
  /** Map as <code>java.sql.Timestamp</code> */  
  TIMESTAMP  
}
```
크게 DATE, TIME,TIMESTAMP로 되어있다

 ➕ persistence.xml에서 이름매핑전략을 설정하는 방법은 아래와 같이 옵션을 추가해주면 된다!
 
org.hibernate.cfg.ImprovedNamingStrategy

▶ 자바의 카멜 표기법을 테이블의 언더바 표기법으로 변경해주는 클래스!!

```
<!--이름 매핑 전략-->  
<property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence" version="2.1">  
 <persistence-unit name="jpabook">  
         <properties>  
  <!--필수속성-->  
  <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>  
 <property name="javax.persistence.jdbc.user" value="sa"/>  
 <property name="javax.persistence.jdbc.password" value=""/>  
 <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>  
 <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>  
  
  <!--선택속성-->  
  <property name="hibernate.show_sql" value="true"/>  
 <property name="hibernate.format_sql" value="true"/>  
  <!--애플리케이션 실행 시점에 db 테이블을 자동으로 생성-->  
  <property name="hibernate.hbm2ddl.auto" value="create"/>  
  <!--이름 매핑 전략-->  
  <property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>  
 </properties> </persistence-unit></persistence>
 ```


### 01-3. DDL 생성 기능

@Column에 대해서 알아보기 위해서
Column 인터페이스를 분석해보자

```java
/*  
 * Copyright (c) 2008, 2019 Oracle and/or its affiliates. All rights reserved. * * This program and the accompanying materials are made available under the * terms of the Eclipse Public License v. 2.0 which is available at * http://www.eclipse.org/legal/epl-2.0, * or the Eclipse Distribution License v. 1.0 which is available at * http://www.eclipse.org/org/documents/edl-v10.php. * * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause */  
// Contributors:  
//     Linda DeMichiel - 2.1  
//     Linda DeMichiel - 2.0  
  
  
package javax.persistence;  
  
import java.lang.annotation.Target;  
import java.lang.annotation.Retention;  
import static java.lang.annotation.ElementType.METHOD;  
import static java.lang.annotation.ElementType.FIELD;  
import static java.lang.annotation.RetentionPolicy.RUNTIME;  
  
@Target({METHOD, FIELD})   
@Retention(RUNTIME)  
public @interface Column {  
  
  String name() default "";  

  boolean unique() default false;  
  
  boolean nullable() default true;  
  
  boolean insertable() default true;  

  boolean updatable() default true;  

  String columnDefinition() default "";  
  
  String table() default "";  
 
     int length() default 255;  
  
     int precision() default 0;  
  
     int scale() default 0;  
}
```

(1) name 속성

- 테이블의 어떤 컬럼명과 매핑할 것인지를 명시

(2) unique 속성

- 해당 속성이 고유키 제약조건에 해당하는지 t/f로 명시

(3) insertable 속성

- INSERT 쿼리에 해당 속성을 포함시킬 것인지를 t/f로 명시

(4) updatable 속성

- UPDATE 쿼리에 해당 속성을 포함시킬 것인지를 t/f로 명시

(5) nullable 속성

- 해당 속성이 null이어도 되는지를 t/f로 명시

(6) length 속성

- String 타입을 갖는 열에 대해서 길이를 지정(int 값이므로 최대 약 21억 크기까지 지정 가능)

etc...

---------

(1) 만약, 이름 속성에 대해서 NOT NULL이어야 하고, 최대 길이가 10글자를 넘어가면 안된다면 아래와 같이 지정해주면 된다!

```java
@Column(name="NAME",nullable = false, length = 10)  
private String name;
```
```java
package com.example.ch04jpastart2.jpabook.start;  
  
import lombok.AllArgsConstructor;  
import lombok.Data;  
import lombok.NoArgsConstructor;  
  
import javax.persistence.*;  
import java.time.LocalDateTime;  
  
@Entity  
@Table(name="MEMBER")  
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class Member {  
    @Id  
 @GeneratedValue(strategy = GenerationType.AUTO)  
    @Column(name="ID")  
    private Long id;  
  
  @Column(name="NAME",nullable = false, length = 10)  
    private String name;  
  
  @Column(name="AGE")  
    private Integer age;  
  
  @Enumerated(EnumType.STRING)  
    private RoleType roleType;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private LocalDateTime createdAt;  
  
  @Temporal(TemporalType.TIMESTAMP)  
    private LocalDateTime updatedAt;  
  
  @Lob  
  private String description;  
}
```

이렇게 되면 아래와 같은 DDL이 실행된 것과 같다!

```sql
CREATE TABLE MEMBER(
	ID LONG PRIMARY KEY,
	NAME VARCHAR(10) NOT NULL,
	AGE INTEGER,
	ROLETYPE VARCHAR(255),
	CREATEDAT TIMESTAMP,
   UPDATEDAT TIMESTAMP,
   DESCRIPTION CLOB
);
```

(2) 만약 , 여기서 "name"과 "age" 컬럼에 대해서 고유키 제약조건을 걸고 싶다면? 

➕ UniqueConstraint 속성에는 어떤것이 있는지 확인하기

```java
package javax.persistence;  
  
import java.lang.annotation.Target;  
import java.lang.annotation.Retention;  
import static java.lang.annotation.RetentionPolicy.RUNTIME;  
  
@Target({})   
@Retention(RUNTIME)  
public @interface UniqueConstraint {  
  
  String name() default "";   

  String[] columnNames();  
}
```

- name 속성 : 제약조건명
- columnNames 속성: 어떤 컬럼(들)에 제약조건을 걸어줄 것인지 명시


